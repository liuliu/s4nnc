// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/saved_object_graph.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Tensorboard_SavedObjectGraph: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flattened list of objects in the object graph.
  ///
  /// The position of the object in this list indicates its id.
  /// Nodes[0] is considered the root node.
  var nodes: [Tensorboard_SavedObject] = []

  /// Information about captures and output structures in concrete functions.
  /// Referenced from SavedBareConcreteFunction and SavedFunction.
  var concreteFunctions: Dictionary<String,Tensorboard_SavedConcreteFunction> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_SavedObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Objects which this object depends on: named edges in the dependency
  /// graph.
  ///
  /// Note: All kinds of SavedObject may have children, except
  /// "constant" and "captured_tensor".
  var children: [Tensorboard_TrackableObjectGraph.TrackableObject.ObjectReference] = []

  /// Ordered list of dependencies that must be loaded before this object.
  /// SavedModel loads with the bottom-up approach, by first creating all objects
  /// (in the order defined by the dependencies), then connecting the edges.
  var dependencies: [Tensorboard_TrackableObjectGraph.TrackableObject.ObjectReference] = []

  /// Slot variables owned by this object. This describes the three-way
  /// (optimizer, variable, slot variable) relationship; none of the three
  /// depend on the others directly.
  ///
  /// Note: currently only valid if kind == "user_object".
  var slotVariables: [Tensorboard_TrackableObjectGraph.TrackableObject.SlotVariableReference] = []

  var kind: Tensorboard_SavedObject.OneOf_Kind? = nil

  var userObject: Tensorboard_SavedUserObject {
    get {
      if case .userObject(let v)? = kind {return v}
      return Tensorboard_SavedUserObject()
    }
    set {kind = .userObject(newValue)}
  }

  var asset: Tensorboard_SavedAsset {
    get {
      if case .asset(let v)? = kind {return v}
      return Tensorboard_SavedAsset()
    }
    set {kind = .asset(newValue)}
  }

  var function: Tensorboard_SavedFunction {
    get {
      if case .function(let v)? = kind {return v}
      return Tensorboard_SavedFunction()
    }
    set {kind = .function(newValue)}
  }

  var variable: Tensorboard_SavedVariable {
    get {
      if case .variable(let v)? = kind {return v}
      return Tensorboard_SavedVariable()
    }
    set {kind = .variable(newValue)}
  }

  var bareConcreteFunction: Tensorboard_SavedBareConcreteFunction {
    get {
      if case .bareConcreteFunction(let v)? = kind {return v}
      return Tensorboard_SavedBareConcreteFunction()
    }
    set {kind = .bareConcreteFunction(newValue)}
  }

  var constant: Tensorboard_SavedConstant {
    get {
      if case .constant(let v)? = kind {return v}
      return Tensorboard_SavedConstant()
    }
    set {kind = .constant(newValue)}
  }

  var resource: Tensorboard_SavedResource {
    get {
      if case .resource(let v)? = kind {return v}
      return Tensorboard_SavedResource()
    }
    set {kind = .resource(newValue)}
  }

  var capturedTensor: Tensorboard_CapturedTensor {
    get {
      if case .capturedTensor(let v)? = kind {return v}
      return Tensorboard_CapturedTensor()
    }
    set {kind = .capturedTensor(newValue)}
  }

  /// Stores the functions used to save and restore this object. At most one of
  /// `saveable_objects` or `registered_saver` is defined for each SavedObject.
  /// See the comment below for the difference between SaveableObject and
  /// registered savers.
  var saveableObjects: Dictionary<String,Tensorboard_SaveableObject> = [:]

  /// The name of the registered class of the form "{package}.{class_name}".
  /// This field is used to search for the registered class at loading time.
  var registeredName: String = String()

  /// The user-generated proto storing metadata for this object, to be passed to
  /// the registered classes's _deserialize_from_proto method when this object is
  /// loaded from the SavedModel.
  var serializedUserProto: SwiftProtobuf.Google_Protobuf_Any {
    get {return _serializedUserProto ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_serializedUserProto = newValue}
  }
  /// Returns true if `serializedUserProto` has been explicitly set.
  var hasSerializedUserProto: Bool {return self._serializedUserProto != nil}
  /// Clears the value of `serializedUserProto`. Subsequent reads from it will return its default value.
  mutating func clearSerializedUserProto() {self._serializedUserProto = nil}

  /// String name of the registered saver. At most one of `saveable_objects` or
  /// `registered_saver` is defined for each SavedObject.
  var registeredSaver: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case userObject(Tensorboard_SavedUserObject)
    case asset(Tensorboard_SavedAsset)
    case function(Tensorboard_SavedFunction)
    case variable(Tensorboard_SavedVariable)
    case bareConcreteFunction(Tensorboard_SavedBareConcreteFunction)
    case constant(Tensorboard_SavedConstant)
    case resource(Tensorboard_SavedResource)
    case capturedTensor(Tensorboard_CapturedTensor)

  }

  init() {}

  fileprivate var _serializedUserProto: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// A SavedUserObject is an object (in the object-oriented language of the
/// TensorFlow program) of some user- or framework-defined class other than
/// those handled specifically by the other kinds of SavedObjects.
///
/// This object cannot be evaluated as a tensor, and therefore cannot be bound
/// to an input of a function.
struct Tensorboard_SavedUserObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Corresponds to a registration of the type to use in the loading program.
  var identifier: String = String()

  /// Version information from the producer of this SavedUserObject.
  var version: Tensorboard_VersionDef {
    get {return _version ?? Tensorboard_VersionDef()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  /// Metadata for deserializing this object.
  ///
  /// Deprecated! At the time of deprecation, Keras was the only user of this
  /// field, and its saving and loading code will be updated shortly.
  /// Please save your application-specific metadata to a separate file.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var metadata: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Tensorboard_VersionDef? = nil
}

/// A SavedAsset points to an asset in the MetaGraph.
///
/// When bound to a function this object evaluates to a tensor with the absolute
/// filename. Users should not depend on a particular part of the filename to
/// remain stable (e.g. basename could be changed).
struct Tensorboard_SavedAsset: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index into `MetaGraphDef.asset_file_def[]` that describes the Asset.
  ///
  /// Only the field `AssetFileDef.filename` is used. Other fields, such as
  /// `AssetFileDef.tensor_info`, MUST be ignored.
  var assetFileDefIndex: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A function with multiple signatures, possibly with non-Tensor arguments.
struct Tensorboard_SavedFunction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var concreteFunctions: [String] = []

  var functionSpec: Tensorboard_FunctionSpec {
    get {return _functionSpec ?? Tensorboard_FunctionSpec()}
    set {_functionSpec = newValue}
  }
  /// Returns true if `functionSpec` has been explicitly set.
  var hasFunctionSpec: Bool {return self._functionSpec != nil}
  /// Clears the value of `functionSpec`. Subsequent reads from it will return its default value.
  mutating func clearFunctionSpec() {self._functionSpec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _functionSpec: Tensorboard_FunctionSpec? = nil
}

struct Tensorboard_CapturedTensor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of captured tensor
  var name: String = String()

  /// Name of concrete function which contains the computed graph tensor.
  var concreteFunction: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Stores low-level information about a concrete function. Referenced in either
/// a SavedFunction or a SavedBareConcreteFunction.
struct Tensorboard_SavedConcreteFunction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var boundInputs: [Int32] = []

  /// Input in canonicalized form that was received to create this concrete
  /// function.
  var canonicalizedInputSignature: Tensorboard_StructuredValue {
    get {return _canonicalizedInputSignature ?? Tensorboard_StructuredValue()}
    set {_canonicalizedInputSignature = newValue}
  }
  /// Returns true if `canonicalizedInputSignature` has been explicitly set.
  var hasCanonicalizedInputSignature: Bool {return self._canonicalizedInputSignature != nil}
  /// Clears the value of `canonicalizedInputSignature`. Subsequent reads from it will return its default value.
  mutating func clearCanonicalizedInputSignature() {self._canonicalizedInputSignature = nil}

  /// Output that was the return value of this function after replacing all
  /// Tensors with TensorSpecs. This can be an arbitrary nested function and will
  /// be used to reconstruct the full structure from pure tensors.
  var outputSignature: Tensorboard_StructuredValue {
    get {return _outputSignature ?? Tensorboard_StructuredValue()}
    set {_outputSignature = newValue}
  }
  /// Returns true if `outputSignature` has been explicitly set.
  var hasOutputSignature: Bool {return self._outputSignature != nil}
  /// Clears the value of `outputSignature`. Subsequent reads from it will return its default value.
  mutating func clearOutputSignature() {self._outputSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _canonicalizedInputSignature: Tensorboard_StructuredValue? = nil
  fileprivate var _outputSignature: Tensorboard_StructuredValue? = nil
}

struct Tensorboard_SavedBareConcreteFunction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies a SavedConcreteFunction.
  var concreteFunctionName: String = String()

  /// A sequence of unique strings, one per Tensor argument.
  var argumentKeywords: [String] = []

  /// The prefix of `argument_keywords` which may be identified by position.
  var allowedPositionalArguments: Int64 = 0

  /// The spec of the function that this ConcreteFunction is traced from. This
  /// allows the ConcreteFunction to be called with nest structure inputs. This
  /// field may not be populated. If this field is absent, the concrete function
  /// can only be called with flat inputs.
  /// TODO(b/169361281): support calling saved ConcreteFunction with structured
  /// inputs in C++ SavedModel API.
  var functionSpec: Tensorboard_FunctionSpec {
    get {return _functionSpec ?? Tensorboard_FunctionSpec()}
    set {_functionSpec = newValue}
  }
  /// Returns true if `functionSpec` has been explicitly set.
  var hasFunctionSpec: Bool {return self._functionSpec != nil}
  /// Clears the value of `functionSpec`. Subsequent reads from it will return its default value.
  mutating func clearFunctionSpec() {self._functionSpec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _functionSpec: Tensorboard_FunctionSpec? = nil
}

struct Tensorboard_SavedConstant: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An Operation name for a ConstantOp in this SavedObjectGraph's MetaGraph.
  var operation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a Variable that is initialized by loading the contents from the
/// checkpoint.
struct Tensorboard_SavedVariable: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dtype: Tensorboard_DataType = .dtInvalid

  var shape: Tensorboard_TensorShapeProto {
    get {return _shape ?? Tensorboard_TensorShapeProto()}
    set {_shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  var hasShape: Bool {return self._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  mutating func clearShape() {self._shape = nil}

  var trainable: Bool = false

  var synchronization: Tensorboard_VariableSynchronization = .auto

  var aggregation: Tensorboard_VariableAggregation = .none

  var name: String = String()

  var device: String = String()

  /// List of component variables for a distributed variable.
  ///
  /// When this field is non-empty, the SavedVariable will be assumed
  /// to be a distributed variable defined by the components listed here.
  ///
  /// This is only supported by experimental loaders at the moment.
  var experimentalDistributedVariableComponents: [Tensorboard_SavedVariable] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shape: Tensorboard_TensorShapeProto? = nil
}

/// Represents `FunctionSpec` used in `Function`. This represents a
/// function that has been wrapped as a TensorFlow `Function`.
struct Tensorboard_FunctionSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full arg spec from inspect.getfullargspec().
  var fullargspec: Tensorboard_StructuredValue {
    get {return _fullargspec ?? Tensorboard_StructuredValue()}
    set {_fullargspec = newValue}
  }
  /// Returns true if `fullargspec` has been explicitly set.
  var hasFullargspec: Bool {return self._fullargspec != nil}
  /// Clears the value of `fullargspec`. Subsequent reads from it will return its default value.
  mutating func clearFullargspec() {self._fullargspec = nil}

  /// Whether this represents a class method.
  var isMethod: Bool = false

  /// The input signature, if specified.
  var inputSignature: Tensorboard_StructuredValue {
    get {return _inputSignature ?? Tensorboard_StructuredValue()}
    set {_inputSignature = newValue}
  }
  /// Returns true if `inputSignature` has been explicitly set.
  var hasInputSignature: Bool {return self._inputSignature != nil}
  /// Clears the value of `inputSignature`. Subsequent reads from it will return its default value.
  mutating func clearInputSignature() {self._inputSignature = nil}

  var jitCompile: Tensorboard_FunctionSpec.JitCompile = .default

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Whether the function should be compiled by XLA.
  ///
  /// The public interface to `tf.function` uses an optional boolean to
  /// represent three distinct states for this field.  Unfortunately, proto3
  /// removes the ability to explicitly check for the presence or absence of a
  /// field, so we instead map to an enum.
  ///
  /// See `tf.function` for details.
  enum JitCompile: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case `default` // = 0
    case on // = 1
    case off // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .on
      case 2: self = .off
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .on: return 1
      case .off: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Tensorboard_FunctionSpec.JitCompile] = [
      .default,
      .on,
      .off,
    ]

  }

  init() {}

  fileprivate var _fullargspec: Tensorboard_StructuredValue? = nil
  fileprivate var _inputSignature: Tensorboard_StructuredValue? = nil
}

/// A SavedResource represents a TF object that holds state during its lifetime.
/// An object of this type can have a reference to a:
/// create_resource() and an initialize() function.
struct Tensorboard_SavedResource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A device specification indicating a required placement for the resource
  /// creation function, e.g. "CPU". An empty string allows the user to select a
  /// device.
  var device: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_SaveableObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Node ids of concrete functions for saving and loading from a checkpoint.
  /// These functions save and restore directly from tensors.
  var saveFunction: Int32 = 0

  var restoreFunction: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_SavedObjectGraph: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedObjectGraph"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "concrete_functions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_SavedConcreteFunction>.self, value: &self.concreteFunctions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if !self.concreteFunctions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_SavedConcreteFunction>.self, value: self.concreteFunctions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedObjectGraph, rhs: Tensorboard_SavedObjectGraph) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.concreteFunctions != rhs.concreteFunctions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "children"),
    15: .same(proto: "dependencies"),
    3: .standard(proto: "slot_variables"),
    4: .standard(proto: "user_object"),
    5: .same(proto: "asset"),
    6: .same(proto: "function"),
    7: .same(proto: "variable"),
    8: .standard(proto: "bare_concrete_function"),
    9: .same(proto: "constant"),
    10: .same(proto: "resource"),
    12: .standard(proto: "captured_tensor"),
    11: .standard(proto: "saveable_objects"),
    13: .standard(proto: "registered_name"),
    14: .standard(proto: "serialized_user_proto"),
    16: .standard(proto: "registered_saver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.slotVariables) }()
      case 4: try {
        var v: Tensorboard_SavedUserObject?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .userObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .userObject(v)
        }
      }()
      case 5: try {
        var v: Tensorboard_SavedAsset?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .asset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .asset(v)
        }
      }()
      case 6: try {
        var v: Tensorboard_SavedFunction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .function(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .function(v)
        }
      }()
      case 7: try {
        var v: Tensorboard_SavedVariable?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .variable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .variable(v)
        }
      }()
      case 8: try {
        var v: Tensorboard_SavedBareConcreteFunction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .bareConcreteFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .bareConcreteFunction(v)
        }
      }()
      case 9: try {
        var v: Tensorboard_SavedConstant?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .constant(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .constant(v)
        }
      }()
      case 10: try {
        var v: Tensorboard_SavedResource?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .resource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .resource(v)
        }
      }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_SaveableObject>.self, value: &self.saveableObjects) }()
      case 12: try {
        var v: Tensorboard_CapturedTensor?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .capturedTensor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .capturedTensor(v)
        }
      }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.registeredName) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._serializedUserProto) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.dependencies) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.registeredSaver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 1)
    }
    if !self.slotVariables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slotVariables, fieldNumber: 3)
    }
    switch self.kind {
    case .userObject?: try {
      guard case .userObject(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .asset?: try {
      guard case .asset(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .function?: try {
      guard case .function(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .variable?: try {
      guard case .variable(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .bareConcreteFunction?: try {
      guard case .bareConcreteFunction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .constant?: try {
      guard case .constant(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .resource?: try {
      guard case .resource(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    default: break
    }
    if !self.saveableObjects.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_SaveableObject>.self, value: self.saveableObjects, fieldNumber: 11)
    }
    try { if case .capturedTensor(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.registeredName.isEmpty {
      try visitor.visitSingularStringField(value: self.registeredName, fieldNumber: 13)
    }
    try { if let v = self._serializedUserProto {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    if !self.dependencies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dependencies, fieldNumber: 15)
    }
    if !self.registeredSaver.isEmpty {
      try visitor.visitSingularStringField(value: self.registeredSaver, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedObject, rhs: Tensorboard_SavedObject) -> Bool {
    if lhs.children != rhs.children {return false}
    if lhs.dependencies != rhs.dependencies {return false}
    if lhs.slotVariables != rhs.slotVariables {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.saveableObjects != rhs.saveableObjects {return false}
    if lhs.registeredName != rhs.registeredName {return false}
    if lhs._serializedUserProto != rhs._serializedUserProto {return false}
    if lhs.registeredSaver != rhs.registeredSaver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedUserObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedUserObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "version"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedUserObject, rhs: Tensorboard_SavedUserObject) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._version != rhs._version {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedAsset"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_file_def_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.assetFileDefIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.assetFileDefIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.assetFileDefIndex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedAsset, rhs: Tensorboard_SavedAsset) -> Bool {
    if lhs.assetFileDefIndex != rhs.assetFileDefIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "concrete_functions"),
    2: .standard(proto: "function_spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.concreteFunctions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._functionSpec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.concreteFunctions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.concreteFunctions, fieldNumber: 1)
    }
    try { if let v = self._functionSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedFunction, rhs: Tensorboard_SavedFunction) -> Bool {
    if lhs.concreteFunctions != rhs.concreteFunctions {return false}
    if lhs._functionSpec != rhs._functionSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CapturedTensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CapturedTensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "concrete_function"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.concreteFunction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.concreteFunction.isEmpty {
      try visitor.visitSingularStringField(value: self.concreteFunction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CapturedTensor, rhs: Tensorboard_CapturedTensor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.concreteFunction != rhs.concreteFunction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedConcreteFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedConcreteFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "bound_inputs"),
    3: .standard(proto: "canonicalized_input_signature"),
    4: .standard(proto: "output_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.boundInputs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._canonicalizedInputSignature) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outputSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.boundInputs.isEmpty {
      try visitor.visitPackedInt32Field(value: self.boundInputs, fieldNumber: 2)
    }
    try { if let v = self._canonicalizedInputSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outputSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedConcreteFunction, rhs: Tensorboard_SavedConcreteFunction) -> Bool {
    if lhs.boundInputs != rhs.boundInputs {return false}
    if lhs._canonicalizedInputSignature != rhs._canonicalizedInputSignature {return false}
    if lhs._outputSignature != rhs._outputSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedBareConcreteFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedBareConcreteFunction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "concrete_function_name"),
    2: .standard(proto: "argument_keywords"),
    3: .standard(proto: "allowed_positional_arguments"),
    4: .standard(proto: "function_spec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.concreteFunctionName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.argumentKeywords) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.allowedPositionalArguments) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._functionSpec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.concreteFunctionName.isEmpty {
      try visitor.visitSingularStringField(value: self.concreteFunctionName, fieldNumber: 1)
    }
    if !self.argumentKeywords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.argumentKeywords, fieldNumber: 2)
    }
    if self.allowedPositionalArguments != 0 {
      try visitor.visitSingularInt64Field(value: self.allowedPositionalArguments, fieldNumber: 3)
    }
    try { if let v = self._functionSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedBareConcreteFunction, rhs: Tensorboard_SavedBareConcreteFunction) -> Bool {
    if lhs.concreteFunctionName != rhs.concreteFunctionName {return false}
    if lhs.argumentKeywords != rhs.argumentKeywords {return false}
    if lhs.allowedPositionalArguments != rhs.allowedPositionalArguments {return false}
    if lhs._functionSpec != rhs._functionSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedConstant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedConstant"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedConstant, rhs: Tensorboard_SavedConstant) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SavedVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedVariable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dtype"),
    2: .same(proto: "shape"),
    3: .same(proto: "trainable"),
    4: .same(proto: "synchronization"),
    5: .same(proto: "aggregation"),
    6: .same(proto: "name"),
    7: .same(proto: "device"),
    8: .standard(proto: "experimental_distributed_variable_components"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dtype) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trainable) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.synchronization) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.aggregation) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.experimentalDistributedVariableComponents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dtype != .dtInvalid {
      try visitor.visitSingularEnumField(value: self.dtype, fieldNumber: 1)
    }
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.trainable != false {
      try visitor.visitSingularBoolField(value: self.trainable, fieldNumber: 3)
    }
    if self.synchronization != .auto {
      try visitor.visitSingularEnumField(value: self.synchronization, fieldNumber: 4)
    }
    if self.aggregation != .none {
      try visitor.visitSingularEnumField(value: self.aggregation, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 7)
    }
    if !self.experimentalDistributedVariableComponents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.experimentalDistributedVariableComponents, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedVariable, rhs: Tensorboard_SavedVariable) -> Bool {
    if lhs.dtype != rhs.dtype {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.trainable != rhs.trainable {return false}
    if lhs.synchronization != rhs.synchronization {return false}
    if lhs.aggregation != rhs.aggregation {return false}
    if lhs.name != rhs.name {return false}
    if lhs.device != rhs.device {return false}
    if lhs.experimentalDistributedVariableComponents != rhs.experimentalDistributedVariableComponents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_FunctionSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FunctionSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullargspec"),
    2: .standard(proto: "is_method"),
    5: .standard(proto: "input_signature"),
    6: .standard(proto: "jit_compile"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fullargspec) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isMethod) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._inputSignature) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.jitCompile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fullargspec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isMethod != false {
      try visitor.visitSingularBoolField(value: self.isMethod, fieldNumber: 2)
    }
    try { if let v = self._inputSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.jitCompile != .default {
      try visitor.visitSingularEnumField(value: self.jitCompile, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_FunctionSpec, rhs: Tensorboard_FunctionSpec) -> Bool {
    if lhs._fullargspec != rhs._fullargspec {return false}
    if lhs.isMethod != rhs.isMethod {return false}
    if lhs._inputSignature != rhs._inputSignature {return false}
    if lhs.jitCompile != rhs.jitCompile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_FunctionSpec.JitCompile: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "ON"),
    2: .same(proto: "OFF"),
  ]
}

extension Tensorboard_SavedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SavedResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SavedResource, rhs: Tensorboard_SavedResource) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SaveableObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SaveableObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "save_function"),
    3: .standard(proto: "restore_function"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.saveFunction) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.restoreFunction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.saveFunction != 0 {
      try visitor.visitSingularInt32Field(value: self.saveFunction, fieldNumber: 2)
    }
    if self.restoreFunction != 0 {
      try visitor.visitSingularInt32Field(value: self.restoreFunction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SaveableObject, rhs: Tensorboard_SaveableObject) -> Bool {
    if lhs.saveFunction != rhs.saveFunction {return false}
    if lhs.restoreFunction != rhs.restoreFunction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
