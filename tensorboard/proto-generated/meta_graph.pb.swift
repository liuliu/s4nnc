// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/meta_graph.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// NOTE: This protocol buffer is evolving, and will go through revisions in the
/// coming months.
///
/// Protocol buffer containing the following which are necessary to restart
/// training, run inference. It can be used to serialize/de-serialize memory
/// objects necessary for running computation in a graph when crossing the
/// process boundary. It can be used for long term storage of graphs,
/// cross-language execution of graphs, etc.
///   MetaInfoDef
///   GraphDef
///   SaverDef
///   CollectionDef
///   TensorInfo
///   SignatureDef
struct Tensorboard_MetaGraphDef: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metaInfoDef: Tensorboard_MetaGraphDef.MetaInfoDef {
    get {return _storage._metaInfoDef ?? Tensorboard_MetaGraphDef.MetaInfoDef()}
    set {_uniqueStorage()._metaInfoDef = newValue}
  }
  /// Returns true if `metaInfoDef` has been explicitly set.
  var hasMetaInfoDef: Bool {return _storage._metaInfoDef != nil}
  /// Clears the value of `metaInfoDef`. Subsequent reads from it will return its default value.
  mutating func clearMetaInfoDef() {_uniqueStorage()._metaInfoDef = nil}

  /// GraphDef.
  var graphDef: Tensorboard_GraphDef {
    get {return _storage._graphDef ?? Tensorboard_GraphDef()}
    set {_uniqueStorage()._graphDef = newValue}
  }
  /// Returns true if `graphDef` has been explicitly set.
  var hasGraphDef: Bool {return _storage._graphDef != nil}
  /// Clears the value of `graphDef`. Subsequent reads from it will return its default value.
  mutating func clearGraphDef() {_uniqueStorage()._graphDef = nil}

  /// SaverDef.
  var saverDef: Tensorboard_SaverDef {
    get {return _storage._saverDef ?? Tensorboard_SaverDef()}
    set {_uniqueStorage()._saverDef = newValue}
  }
  /// Returns true if `saverDef` has been explicitly set.
  var hasSaverDef: Bool {return _storage._saverDef != nil}
  /// Clears the value of `saverDef`. Subsequent reads from it will return its default value.
  mutating func clearSaverDef() {_uniqueStorage()._saverDef = nil}

  /// collection_def: Map from collection name to collections.
  /// See CollectionDef section for details.
  var collectionDef: Dictionary<String,Tensorboard_CollectionDef> {
    get {return _storage._collectionDef}
    set {_uniqueStorage()._collectionDef = newValue}
  }

  /// signature_def: Map from user supplied key for a signature to a single
  /// SignatureDef.
  var signatureDef: Dictionary<String,Tensorboard_SignatureDef> {
    get {return _storage._signatureDef}
    set {_uniqueStorage()._signatureDef = newValue}
  }

  /// Asset file def to be used with the defined graph.
  var assetFileDef: [Tensorboard_AssetFileDef] {
    get {return _storage._assetFileDef}
    set {_uniqueStorage()._assetFileDef = newValue}
  }

  /// Extra information about the structure of functions and stateful objects.
  var objectGraphDef: Tensorboard_SavedObjectGraph {
    get {return _storage._objectGraphDef ?? Tensorboard_SavedObjectGraph()}
    set {_uniqueStorage()._objectGraphDef = newValue}
  }
  /// Returns true if `objectGraphDef` has been explicitly set.
  var hasObjectGraphDef: Bool {return _storage._objectGraphDef != nil}
  /// Clears the value of `objectGraphDef`. Subsequent reads from it will return its default value.
  mutating func clearObjectGraphDef() {_uniqueStorage()._objectGraphDef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Meta information regarding the graph to be exported.  To be used by users
  /// of this protocol buffer to encode information regarding their meta graph.
  struct MetaInfoDef: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User specified Version string. Can be the name of the model and revision,
    /// steps this model has been trained to, etc.
    var metaGraphVersion: String = String()

    /// A copy of the OpDefs used by the producer of this graph_def.
    /// Descriptions and Ops not used in graph_def are stripped out.
    var strippedOpList: Tensorboard_OpList {
      get {return _strippedOpList ?? Tensorboard_OpList()}
      set {_strippedOpList = newValue}
    }
    /// Returns true if `strippedOpList` has been explicitly set.
    var hasStrippedOpList: Bool {return self._strippedOpList != nil}
    /// Clears the value of `strippedOpList`. Subsequent reads from it will return its default value.
    mutating func clearStrippedOpList() {self._strippedOpList = nil}

    /// A serialized protobuf. Can be the time this meta graph is created, or
    /// modified, or name of the model.
    var anyInfo: SwiftProtobuf.Google_Protobuf_Any {
      get {return _anyInfo ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_anyInfo = newValue}
    }
    /// Returns true if `anyInfo` has been explicitly set.
    var hasAnyInfo: Bool {return self._anyInfo != nil}
    /// Clears the value of `anyInfo`. Subsequent reads from it will return its default value.
    mutating func clearAnyInfo() {self._anyInfo = nil}

    /// User supplied tag(s) on the meta_graph and included graph_def.
    ///
    /// MetaGraphDefs should be tagged with their capabilities or use-cases.
    /// Examples: "train", "serve", "gpu", "tpu", etc.
    /// These tags enable loaders to access the MetaGraph(s) appropriate for a
    /// specific use-case or runtime environment.
    var tags: [String] = []

    /// The __version__ string of the tensorflow build used to write this graph.
    /// This will be populated by the framework, which will overwrite any user
    /// supplied value.
    var tensorflowVersion: String = String()

    /// The __git_version__ string of the tensorflow build used to write this
    /// graph. This will be populated by the framework, which will overwrite any
    /// user supplied value.
    var tensorflowGitVersion: String = String()

    /// A flag to denote whether default-valued attrs have been stripped from
    /// the nodes in this graph_def.
    var strippedDefaultAttrs: Bool = false

    /// FunctionDef name to aliases mapping.
    var functionAliases: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _strippedOpList: Tensorboard_OpList? = nil
    fileprivate var _anyInfo: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CollectionDef should cover most collections.
/// To add a user-defined collection, do one of the following:
/// 1. For simple data types, such as string, int, float:
///      tf.add_to_collection("your_collection_name", your_simple_value)
///    strings will be stored as bytes_list.
///
/// 2. For Protobuf types, there are three ways to add them:
///    1) tf.add_to_collection("your_collection_name",
///         your_proto.SerializeToString())
///
///       collection_def {
///         key: "user_defined_bytes_collection"
///         value {
///           bytes_list {
///             value: "queue_name: \"test_queue\"\n"
///           }
///         }
///       }
///
///  or
///
///    2) tf.add_to_collection("your_collection_name", str(your_proto))
///
///       collection_def {
///         key: "user_defined_string_collection"
///         value {
///          bytes_list {
///             value: "\n\ntest_queue"
///           }
///         }
///       }
///
///  or
///
///    3) any_buf = any_pb2.Any()
///       tf.add_to_collection("your_collection_name",
///         any_buf.Pack(your_proto))
///
///       collection_def {
///         key: "user_defined_any_collection"
///         value {
///           any_list {
///             value {
///               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
///               value: "\n\ntest_queue"
///             }
///           }
///         }
///       }
///
/// 3. For Python objects, implement to_proto() and from_proto(), and register
///    them in the following manner:
///    ops.register_proto_function("your_collection_name",
///                                proto_type,
///                                to_proto=YourPythonObject.to_proto,
///                                from_proto=YourPythonObject.from_proto)
///    These functions will be invoked to serialize and de-serialize the
///    collection. For example,
///    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
///                                proto_type=variable_pb2.VariableDef,
///                                to_proto=Variable.to_proto,
///                                from_proto=Variable.from_proto)
struct Tensorboard_CollectionDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Tensorboard_CollectionDef.OneOf_Kind? = nil

  var nodeList: Tensorboard_CollectionDef.NodeList {
    get {
      if case .nodeList(let v)? = kind {return v}
      return Tensorboard_CollectionDef.NodeList()
    }
    set {kind = .nodeList(newValue)}
  }

  var bytesList: Tensorboard_CollectionDef.BytesList {
    get {
      if case .bytesList(let v)? = kind {return v}
      return Tensorboard_CollectionDef.BytesList()
    }
    set {kind = .bytesList(newValue)}
  }

  var int64List: Tensorboard_CollectionDef.Int64List {
    get {
      if case .int64List(let v)? = kind {return v}
      return Tensorboard_CollectionDef.Int64List()
    }
    set {kind = .int64List(newValue)}
  }

  var floatList: Tensorboard_CollectionDef.FloatList {
    get {
      if case .floatList(let v)? = kind {return v}
      return Tensorboard_CollectionDef.FloatList()
    }
    set {kind = .floatList(newValue)}
  }

  var anyList: Tensorboard_CollectionDef.AnyList {
    get {
      if case .anyList(let v)? = kind {return v}
      return Tensorboard_CollectionDef.AnyList()
    }
    set {kind = .anyList(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case nodeList(Tensorboard_CollectionDef.NodeList)
    case bytesList(Tensorboard_CollectionDef.BytesList)
    case int64List(Tensorboard_CollectionDef.Int64List)
    case floatList(Tensorboard_CollectionDef.FloatList)
    case anyList(Tensorboard_CollectionDef.AnyList)

  }

  /// NodeList is used for collecting nodes in graph. For example
  /// collection_def {
  ///   key: "summaries"
  ///   value {
  ///     node_list {
  ///       value: "input_producer/ScalarSummary:0"
  ///       value: "shuffle_batch/ScalarSummary:0"
  ///       value: "ImageSummary:0"
  ///     }
  ///   }
  struct NodeList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// BytesList is used for collecting strings and serialized protobufs. For
  /// example:
  /// collection_def {
  ///   key: "trainable_variables"
  ///   value {
  ///     bytes_list {
  ///       value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
  ///              \032\024conv1/weights/read:0"
  ///       value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
  ///              \023conv1/biases/read:0"
  ///     }
  ///   }
  /// }
  struct BytesList: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Int64List is used for collecting int, int64 and long values.
  struct Int64List: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: [Int64] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// FloatList is used for collecting float values.
  struct FloatList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: [Float] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// AnyList is used for collecting Any protos.
  struct AnyList: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: [SwiftProtobuf.Google_Protobuf_Any] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Information about a Tensor necessary for feeding or retrieval.
struct Tensorboard_TensorInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encoding: Tensorboard_TensorInfo.OneOf_Encoding? = nil

  /// For dense `Tensor`s, the name of the tensor in the graph.
  var name: String {
    get {
      if case .name(let v)? = encoding {return v}
      return String()
    }
    set {encoding = .name(newValue)}
  }

  /// There are many possible encodings of sparse matrices
  /// (https://en.wikipedia.org/wiki/Sparse_matrix).  Currently, TensorFlow
  /// uses only the COO encoding.  This is supported and documented in the
  /// SparseTensor Python class.
  var cooSparse: Tensorboard_TensorInfo.CooSparse {
    get {
      if case .cooSparse(let v)? = encoding {return v}
      return Tensorboard_TensorInfo.CooSparse()
    }
    set {encoding = .cooSparse(newValue)}
  }

  /// Generic encoding for CompositeTensors.
  var compositeTensor: Tensorboard_TensorInfo.CompositeTensor {
    get {
      if case .compositeTensor(let v)? = encoding {return v}
      return Tensorboard_TensorInfo.CompositeTensor()
    }
    set {encoding = .compositeTensor(newValue)}
  }

  var dtype: Tensorboard_DataType = .dtInvalid

  /// The static shape should be recorded here, to the extent that it can
  /// be known in advance.  In the case of a SparseTensor, this field describes
  /// the logical shape of the represented tensor (aka dense_shape).
  var tensorShape: Tensorboard_TensorShapeProto {
    get {return _tensorShape ?? Tensorboard_TensorShapeProto()}
    set {_tensorShape = newValue}
  }
  /// Returns true if `tensorShape` has been explicitly set.
  var hasTensorShape: Bool {return self._tensorShape != nil}
  /// Clears the value of `tensorShape`. Subsequent reads from it will return its default value.
  mutating func clearTensorShape() {self._tensorShape = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Encoding: Equatable, Sendable {
    /// For dense `Tensor`s, the name of the tensor in the graph.
    case name(String)
    /// There are many possible encodings of sparse matrices
    /// (https://en.wikipedia.org/wiki/Sparse_matrix).  Currently, TensorFlow
    /// uses only the COO encoding.  This is supported and documented in the
    /// SparseTensor Python class.
    case cooSparse(Tensorboard_TensorInfo.CooSparse)
    /// Generic encoding for CompositeTensors.
    case compositeTensor(Tensorboard_TensorInfo.CompositeTensor)

  }

  /// For sparse tensors, The COO encoding stores a triple of values, indices,
  /// and shape.
  struct CooSparse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The shape of the values Tensor is [?].  Its dtype must be the dtype of
    /// the SparseTensor as a whole, given in the enclosing TensorInfo.
    var valuesTensorName: String = String()

    /// The indices Tensor must have dtype int64 and shape [?, ?].
    var indicesTensorName: String = String()

    /// The dynamic logical shape represented by the SparseTensor is recorded in
    /// the Tensor referenced here.  It must have dtype int64 and shape [?].
    var denseShapeTensorName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Generic encoding for composite tensors.
  struct CompositeTensor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The serialized TypeSpec for the composite tensor.
    var typeSpec: Tensorboard_TypeSpecProto {
      get {return _typeSpec ?? Tensorboard_TypeSpecProto()}
      set {_typeSpec = newValue}
    }
    /// Returns true if `typeSpec` has been explicitly set.
    var hasTypeSpec: Bool {return self._typeSpec != nil}
    /// Clears the value of `typeSpec`. Subsequent reads from it will return its default value.
    mutating func clearTypeSpec() {self._typeSpec = nil}

    /// A TensorInfo for each flattened component tensor.
    var components: [Tensorboard_TensorInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _typeSpec: Tensorboard_TypeSpecProto? = nil
  }

  init() {}

  fileprivate var _tensorShape: Tensorboard_TensorShapeProto? = nil
}

/// SignatureDef defines the signature of a computation supported by a TensorFlow
/// graph.
///
/// For example, a model with two loss computations, sharing a single input,
/// might have the following signature_def map, in a MetaGraphDef message.
///
/// Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
/// output key, and method_name are identical, and will be used by system(s) that
/// implement or rely upon this particular loss method. The output tensor names
/// differ, demonstrating how different outputs can exist for the same method.
///
/// signature_def {
///   key: "loss_A"
///   value {
///     inputs {
///       key: "input"
///       value {
///         name: "input:0"
///         dtype: DT_STRING
///         tensor_shape: ...
///       }
///     }
///     outputs {
///       key: "loss_output"
///       value {
///         name: "loss_output_A:0"
///         dtype: DT_FLOAT
///         tensor_shape: ...
///       }
///     }
///     method_name: "some/package/compute_loss"
///   }
///   ...
/// }
/// signature_def {
///   key: "loss_B"
///   value {
///     inputs {
///       key: "input"
///       value {
///         name: "input:0"
///         dtype: DT_STRING
///         tensor_shape: ...
///       }
///     }
///     outputs {
///       key: "loss_output"
///       value {
///         name: "loss_output_B:0"
///         dtype: DT_FLOAT
///         tensor_shape: ...
///       }
///     }
///     method_name: "some/package/compute_loss"
///   }
///   ...
/// }
struct Tensorboard_SignatureDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Named input parameters.
  var inputs: Dictionary<String,Tensorboard_TensorInfo> = [:]

  /// Named output parameters.
  var outputs: Dictionary<String,Tensorboard_TensorInfo> = [:]

  /// Extensible method_name information enabling third-party users to mark a
  /// SignatureDef as supporting a particular method. This enables producers and
  /// consumers of SignatureDefs, e.g. a model definition library and a serving
  /// library to have a clear hand-off regarding the semantics of a computation.
  ///
  /// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
  /// method_name. This is commonly used to support multi-headed computation,
  /// where a single graph computation may return multiple results.
  var methodName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An asset file def for a single file or a set of sharded files with the same
/// name.
struct Tensorboard_AssetFileDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tensor to bind the asset filename to.
  var tensorInfo: Tensorboard_TensorInfo {
    get {return _tensorInfo ?? Tensorboard_TensorInfo()}
    set {_tensorInfo = newValue}
  }
  /// Returns true if `tensorInfo` has been explicitly set.
  var hasTensorInfo: Bool {return self._tensorInfo != nil}
  /// Clears the value of `tensorInfo`. Subsequent reads from it will return its default value.
  mutating func clearTensorInfo() {self._tensorInfo = nil}

  /// The filename within an assets directory. Note: does not include the path
  /// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
  /// would be "vocab.txt".
  var filename: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tensorInfo: Tensorboard_TensorInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_MetaGraphDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MetaGraphDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meta_info_def"),
    2: .standard(proto: "graph_def"),
    3: .standard(proto: "saver_def"),
    4: .standard(proto: "collection_def"),
    5: .standard(proto: "signature_def"),
    6: .standard(proto: "asset_file_def"),
    7: .standard(proto: "object_graph_def"),
  ]

  fileprivate class _StorageClass {
    var _metaInfoDef: Tensorboard_MetaGraphDef.MetaInfoDef? = nil
    var _graphDef: Tensorboard_GraphDef? = nil
    var _saverDef: Tensorboard_SaverDef? = nil
    var _collectionDef: Dictionary<String,Tensorboard_CollectionDef> = [:]
    var _signatureDef: Dictionary<String,Tensorboard_SignatureDef> = [:]
    var _assetFileDef: [Tensorboard_AssetFileDef] = []
    var _objectGraphDef: Tensorboard_SavedObjectGraph? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _metaInfoDef = source._metaInfoDef
      _graphDef = source._graphDef
      _saverDef = source._saverDef
      _collectionDef = source._collectionDef
      _signatureDef = source._signatureDef
      _assetFileDef = source._assetFileDef
      _objectGraphDef = source._objectGraphDef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._metaInfoDef) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._graphDef) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._saverDef) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_CollectionDef>.self, value: &_storage._collectionDef) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_SignatureDef>.self, value: &_storage._signatureDef) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._assetFileDef) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._objectGraphDef) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._metaInfoDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._graphDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._saverDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._collectionDef.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_CollectionDef>.self, value: _storage._collectionDef, fieldNumber: 4)
      }
      if !_storage._signatureDef.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_SignatureDef>.self, value: _storage._signatureDef, fieldNumber: 5)
      }
      if !_storage._assetFileDef.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._assetFileDef, fieldNumber: 6)
      }
      try { if let v = _storage._objectGraphDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_MetaGraphDef, rhs: Tensorboard_MetaGraphDef) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metaInfoDef != rhs_storage._metaInfoDef {return false}
        if _storage._graphDef != rhs_storage._graphDef {return false}
        if _storage._saverDef != rhs_storage._saverDef {return false}
        if _storage._collectionDef != rhs_storage._collectionDef {return false}
        if _storage._signatureDef != rhs_storage._signatureDef {return false}
        if _storage._assetFileDef != rhs_storage._assetFileDef {return false}
        if _storage._objectGraphDef != rhs_storage._objectGraphDef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_MetaGraphDef.MetaInfoDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_MetaGraphDef.protoMessageName + ".MetaInfoDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meta_graph_version"),
    2: .standard(proto: "stripped_op_list"),
    3: .standard(proto: "any_info"),
    4: .same(proto: "tags"),
    5: .standard(proto: "tensorflow_version"),
    6: .standard(proto: "tensorflow_git_version"),
    7: .standard(proto: "stripped_default_attrs"),
    8: .standard(proto: "function_aliases"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metaGraphVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._strippedOpList) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._anyInfo) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tensorflowVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.tensorflowGitVersion) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.strippedDefaultAttrs) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.functionAliases) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.metaGraphVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.metaGraphVersion, fieldNumber: 1)
    }
    try { if let v = self._strippedOpList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._anyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 4)
    }
    if !self.tensorflowVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.tensorflowVersion, fieldNumber: 5)
    }
    if !self.tensorflowGitVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.tensorflowGitVersion, fieldNumber: 6)
    }
    if self.strippedDefaultAttrs != false {
      try visitor.visitSingularBoolField(value: self.strippedDefaultAttrs, fieldNumber: 7)
    }
    if !self.functionAliases.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.functionAliases, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_MetaGraphDef.MetaInfoDef, rhs: Tensorboard_MetaGraphDef.MetaInfoDef) -> Bool {
    if lhs.metaGraphVersion != rhs.metaGraphVersion {return false}
    if lhs._strippedOpList != rhs._strippedOpList {return false}
    if lhs._anyInfo != rhs._anyInfo {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.tensorflowVersion != rhs.tensorflowVersion {return false}
    if lhs.tensorflowGitVersion != rhs.tensorflowGitVersion {return false}
    if lhs.strippedDefaultAttrs != rhs.strippedDefaultAttrs {return false}
    if lhs.functionAliases != rhs.functionAliases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CollectionDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CollectionDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_list"),
    2: .standard(proto: "bytes_list"),
    3: .standard(proto: "int64_list"),
    4: .standard(proto: "float_list"),
    5: .standard(proto: "any_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tensorboard_CollectionDef.NodeList?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .nodeList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .nodeList(v)
        }
      }()
      case 2: try {
        var v: Tensorboard_CollectionDef.BytesList?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .bytesList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .bytesList(v)
        }
      }()
      case 3: try {
        var v: Tensorboard_CollectionDef.Int64List?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .int64List(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .int64List(v)
        }
      }()
      case 4: try {
        var v: Tensorboard_CollectionDef.FloatList?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .floatList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .floatList(v)
        }
      }()
      case 5: try {
        var v: Tensorboard_CollectionDef.AnyList?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .anyList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .anyList(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .nodeList?: try {
      guard case .nodeList(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bytesList?: try {
      guard case .bytesList(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .int64List?: try {
      guard case .int64List(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .floatList?: try {
      guard case .floatList(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .anyList?: try {
      guard case .anyList(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CollectionDef, rhs: Tensorboard_CollectionDef) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CollectionDef.NodeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_CollectionDef.protoMessageName + ".NodeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CollectionDef.NodeList, rhs: Tensorboard_CollectionDef.NodeList) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CollectionDef.BytesList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_CollectionDef.protoMessageName + ".BytesList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CollectionDef.BytesList, rhs: Tensorboard_CollectionDef.BytesList) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CollectionDef.Int64List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_CollectionDef.protoMessageName + ".Int64List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CollectionDef.Int64List, rhs: Tensorboard_CollectionDef.Int64List) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CollectionDef.FloatList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_CollectionDef.protoMessageName + ".FloatList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitPackedFloatField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CollectionDef.FloatList, rhs: Tensorboard_CollectionDef.FloatList) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CollectionDef.AnyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_CollectionDef.protoMessageName + ".AnyList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CollectionDef.AnyList, rhs: Tensorboard_CollectionDef.AnyList) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TensorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .standard(proto: "coo_sparse"),
    5: .standard(proto: "composite_tensor"),
    2: .same(proto: "dtype"),
    3: .standard(proto: "tensor_shape"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.encoding != nil {try decoder.handleConflictingOneOf()}
          self.encoding = .name(v)
        }
      }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dtype) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tensorShape) }()
      case 4: try {
        var v: Tensorboard_TensorInfo.CooSparse?
        var hadOneofValue = false
        if let current = self.encoding {
          hadOneofValue = true
          if case .cooSparse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.encoding = .cooSparse(v)
        }
      }()
      case 5: try {
        var v: Tensorboard_TensorInfo.CompositeTensor?
        var hadOneofValue = false
        if let current = self.encoding {
          hadOneofValue = true
          if case .compositeTensor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.encoding = .compositeTensor(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .name(let v)? = self.encoding {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if self.dtype != .dtInvalid {
      try visitor.visitSingularEnumField(value: self.dtype, fieldNumber: 2)
    }
    try { if let v = self._tensorShape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.encoding {
    case .cooSparse?: try {
      guard case .cooSparse(let v)? = self.encoding else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .compositeTensor?: try {
      guard case .compositeTensor(let v)? = self.encoding else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_TensorInfo, rhs: Tensorboard_TensorInfo) -> Bool {
    if lhs.encoding != rhs.encoding {return false}
    if lhs.dtype != rhs.dtype {return false}
    if lhs._tensorShape != rhs._tensorShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TensorInfo.CooSparse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_TensorInfo.protoMessageName + ".CooSparse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "values_tensor_name"),
    2: .standard(proto: "indices_tensor_name"),
    3: .standard(proto: "dense_shape_tensor_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.valuesTensorName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.indicesTensorName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.denseShapeTensorName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.valuesTensorName.isEmpty {
      try visitor.visitSingularStringField(value: self.valuesTensorName, fieldNumber: 1)
    }
    if !self.indicesTensorName.isEmpty {
      try visitor.visitSingularStringField(value: self.indicesTensorName, fieldNumber: 2)
    }
    if !self.denseShapeTensorName.isEmpty {
      try visitor.visitSingularStringField(value: self.denseShapeTensorName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_TensorInfo.CooSparse, rhs: Tensorboard_TensorInfo.CooSparse) -> Bool {
    if lhs.valuesTensorName != rhs.valuesTensorName {return false}
    if lhs.indicesTensorName != rhs.indicesTensorName {return false}
    if lhs.denseShapeTensorName != rhs.denseShapeTensorName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TensorInfo.CompositeTensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_TensorInfo.protoMessageName + ".CompositeTensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_spec"),
    2: .same(proto: "components"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._typeSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.components) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._typeSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.components.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.components, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_TensorInfo.CompositeTensor, rhs: Tensorboard_TensorInfo.CompositeTensor) -> Bool {
    if lhs._typeSpec != rhs._typeSpec {return false}
    if lhs.components != rhs.components {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SignatureDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatureDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
    3: .standard(proto: "method_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_TensorInfo>.self, value: &self.inputs) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_TensorInfo>.self, value: &self.outputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_TensorInfo>.self, value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_TensorInfo>.self, value: self.outputs, fieldNumber: 2)
    }
    if !self.methodName.isEmpty {
      try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SignatureDef, rhs: Tensorboard_SignatureDef) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.methodName != rhs.methodName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_AssetFileDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AssetFileDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_info"),
    2: .same(proto: "filename"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tensorInfo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tensorInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_AssetFileDef, rhs: Tensorboard_AssetFileDef) -> Bool {
    if lhs._tensorInfo != rhs._tensorInfo {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
