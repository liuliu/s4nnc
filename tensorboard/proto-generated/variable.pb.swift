// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/variable.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicates when a distributed variable will be synced.
enum Tensorboard_VariableSynchronization: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// `AUTO`: Indicates that the synchronization will be determined by the
  /// current `DistributionStrategy` (eg. With `MirroredStrategy` this would be
  /// `ON_WRITE`).
  case auto // = 0

  /// `NONE`: Indicates that there will only be one copy of the variable, so
  /// there is no need to sync.
  case none // = 1

  /// `ON_WRITE`: Indicates that the variable will be updated across devices
  /// every time it is written.
  case onWrite // = 2

  /// `ON_READ`: Indicates that the variable will be aggregated across devices
  /// when it is read (eg. when checkpointing or when evaluating an op that uses
  /// the variable).
  case onRead // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .auto
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .auto
    case 1: self = .none
    case 2: self = .onWrite
    case 3: self = .onRead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .auto: return 0
    case .none: return 1
    case .onWrite: return 2
    case .onRead: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Tensorboard_VariableSynchronization] = [
    .auto,
    .none,
    .onWrite,
    .onRead,
  ]

}

/// Indicates how a distributed variable will be aggregated.
enum Tensorboard_VariableAggregation: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// `NONE`: This is the default, giving an error if you use a
  /// variable-update operation with multiple replicas.
  case none // = 0

  /// `SUM`: Add the updates across replicas.
  case sum // = 1

  /// `MEAN`: Take the arithmetic mean ("average") of the updates across
  /// replicas.
  case mean // = 2

  /// `ONLY_FIRST_REPLICA`: This is for when every replica is performing the same
  /// update, but we only want to perform the update once. Used, e.g., for the
  /// global step counter.
  case onlyFirstReplica // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .sum
    case 2: self = .mean
    case 3: self = .onlyFirstReplica
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .sum: return 1
    case .mean: return 2
    case .onlyFirstReplica: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Tensorboard_VariableAggregation] = [
    .none,
    .sum,
    .mean,
    .onlyFirstReplica,
  ]

}

/// Protocol buffer representing a Variable.
struct Tensorboard_VariableDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the variable tensor.
  var variableName: String = String()

  /// Name of the tensor holding the variable's initial value.
  var initialValueName: String = String()

  /// Name of the initializer op.
  var initializerName: String = String()

  /// Name of the snapshot tensor.
  var snapshotName: String = String()

  /// Support for saving variables as slices of a larger variable.
  var saveSliceInfoDef: Tensorboard_SaveSliceInfoDef {
    get {return _saveSliceInfoDef ?? Tensorboard_SaveSliceInfoDef()}
    set {_saveSliceInfoDef = newValue}
  }
  /// Returns true if `saveSliceInfoDef` has been explicitly set.
  var hasSaveSliceInfoDef: Bool {return self._saveSliceInfoDef != nil}
  /// Clears the value of `saveSliceInfoDef`. Subsequent reads from it will return its default value.
  mutating func clearSaveSliceInfoDef() {self._saveSliceInfoDef = nil}

  /// Whether to represent this as a ResourceVariable.
  var isResource: Bool = false

  /// Whether this variable should be trained.
  var trainable: Bool = false

  /// Indicates when a distributed variable will be synced.
  var synchronization: Tensorboard_VariableSynchronization = .auto

  /// Indicates how a distributed variable will be aggregated.
  var aggregation: Tensorboard_VariableAggregation = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _saveSliceInfoDef: Tensorboard_SaveSliceInfoDef? = nil
}

struct Tensorboard_SaveSliceInfoDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the full variable of which this is a slice.
  var fullName: String = String()

  /// Shape of the full variable.
  var fullShape: [Int64] = []

  /// Offset of this variable into the full variable.
  var varOffset: [Int64] = []

  /// Shape of this variable.
  var varShape: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_VariableSynchronization: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VARIABLE_SYNCHRONIZATION_AUTO"),
    1: .same(proto: "VARIABLE_SYNCHRONIZATION_NONE"),
    2: .same(proto: "VARIABLE_SYNCHRONIZATION_ON_WRITE"),
    3: .same(proto: "VARIABLE_SYNCHRONIZATION_ON_READ"),
  ]
}

extension Tensorboard_VariableAggregation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VARIABLE_AGGREGATION_NONE"),
    1: .same(proto: "VARIABLE_AGGREGATION_SUM"),
    2: .same(proto: "VARIABLE_AGGREGATION_MEAN"),
    3: .same(proto: "VARIABLE_AGGREGATION_ONLY_FIRST_REPLICA"),
  ]
}

extension Tensorboard_VariableDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariableDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "variable_name"),
    6: .standard(proto: "initial_value_name"),
    2: .standard(proto: "initializer_name"),
    3: .standard(proto: "snapshot_name"),
    4: .standard(proto: "save_slice_info_def"),
    5: .standard(proto: "is_resource"),
    7: .same(proto: "trainable"),
    8: .same(proto: "synchronization"),
    9: .same(proto: "aggregation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variableName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.initializerName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.snapshotName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._saveSliceInfoDef) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isResource) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.initialValueName) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.trainable) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.synchronization) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.aggregation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.variableName.isEmpty {
      try visitor.visitSingularStringField(value: self.variableName, fieldNumber: 1)
    }
    if !self.initializerName.isEmpty {
      try visitor.visitSingularStringField(value: self.initializerName, fieldNumber: 2)
    }
    if !self.snapshotName.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotName, fieldNumber: 3)
    }
    try { if let v = self._saveSliceInfoDef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.isResource != false {
      try visitor.visitSingularBoolField(value: self.isResource, fieldNumber: 5)
    }
    if !self.initialValueName.isEmpty {
      try visitor.visitSingularStringField(value: self.initialValueName, fieldNumber: 6)
    }
    if self.trainable != false {
      try visitor.visitSingularBoolField(value: self.trainable, fieldNumber: 7)
    }
    if self.synchronization != .auto {
      try visitor.visitSingularEnumField(value: self.synchronization, fieldNumber: 8)
    }
    if self.aggregation != .none {
      try visitor.visitSingularEnumField(value: self.aggregation, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_VariableDef, rhs: Tensorboard_VariableDef) -> Bool {
    if lhs.variableName != rhs.variableName {return false}
    if lhs.initialValueName != rhs.initialValueName {return false}
    if lhs.initializerName != rhs.initializerName {return false}
    if lhs.snapshotName != rhs.snapshotName {return false}
    if lhs._saveSliceInfoDef != rhs._saveSliceInfoDef {return false}
    if lhs.isResource != rhs.isResource {return false}
    if lhs.trainable != rhs.trainable {return false}
    if lhs.synchronization != rhs.synchronization {return false}
    if lhs.aggregation != rhs.aggregation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_SaveSliceInfoDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SaveSliceInfoDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_name"),
    2: .standard(proto: "full_shape"),
    3: .standard(proto: "var_offset"),
    4: .standard(proto: "var_shape"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullName) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.fullShape) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.varOffset) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.varShape) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullName, fieldNumber: 1)
    }
    if !self.fullShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.fullShape, fieldNumber: 2)
    }
    if !self.varOffset.isEmpty {
      try visitor.visitPackedInt64Field(value: self.varOffset, fieldNumber: 3)
    }
    if !self.varShape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.varShape, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_SaveSliceInfoDef, rhs: Tensorboard_SaveSliceInfoDef) -> Bool {
    if lhs.fullName != rhs.fullName {return false}
    if lhs.fullShape != rhs.fullShape {return false}
    if lhs.varOffset != rhs.varOffset {return false}
    if lhs.varShape != rhs.varShape {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
