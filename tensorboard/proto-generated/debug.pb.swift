// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/debug.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Option for watching a node in TensorFlow Debugger (tfdbg).
struct Tensorboard_DebugTensorWatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the node to watch.
  /// Use "*" for wildcard. But note: currently, regex is not supported in
  /// general.
  var nodeName: String = String()

  /// Output slot to watch.
  /// The semantics of output_slot == -1 is that all outputs of the node
  /// will be watched (i.e., a wildcard).
  /// Other negative values of output_slot are invalid and will lead to
  /// errors currently.
  var outputSlot: Int32 = 0

  /// Name(s) of the debugging op(s).
  /// One or more than one probes on a tensor.
  /// e.g., {"DebugIdentity", "DebugNanCount"}
  var debugOps: [String] = []

  /// URL(s) for debug targets(s).
  ///
  /// Supported URL formats are:
  ///   - file:///foo/tfdbg_dump: Writes out Event content to file
  ///     /foo/tfdbg_dump.  Assumes all directories can be created if they don't
  ///     already exist.
  ///   - grpc://localhost:11011: Sends an RPC request to an EventListener
  ///     service running at localhost:11011 with the event.
  ///   - memcbk:///event_key: Routes tensors to clients using the
  ///     callback registered with the DebugCallbackRegistry for event_key.
  ///
  /// Each debug op listed in debug_ops will publish its output tensor (debug
  /// signal) to all URLs in debug_urls.
  ///
  /// N.B. Session::Run() supports concurrent invocations of the same inputs
  /// (feed keys), outputs and target nodes. If such concurrent invocations
  /// are to be debugged, the callers of Session::Run() must use distinct
  /// debug_urls to make sure that the streamed or dumped events do not overlap
  /// among the invocations.
  /// TODO(cais): More visible documentation of this in g3docs.
  var debugUrls: [String] = []

  /// Do not error out if debug op creation fails (e.g., due to dtype
  /// incompatibility). Instead, just log the failure.
  var tolerateDebugOpCreationFailures: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Options for initializing DebuggerState in TensorFlow Debugger (tfdbg).
struct Tensorboard_DebugOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Debugging options
  var debugTensorWatchOpts: [Tensorboard_DebugTensorWatch] = []

  /// Caller-specified global step count.
  /// Note that this is distinct from the session run count and the executor
  /// step count.
  var globalStep: Int64 = 0

  /// Whether the total disk usage of tfdbg is to be reset to zero
  /// in this Session.run call. This is used by wrappers and hooks
  /// such as the local CLI ones to indicate that the dumped tensors
  /// are cleaned up from the disk after each Session.run.
  var resetDiskByteUsage: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_DebuggedSourceFile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The host name on which a source code file is located.
  var host: String = String()

  /// Path to the source code file.
  var filePath: String = String()

  /// The timestamp at which the source code file is last modified.
  var lastModified: Int64 = 0

  /// Byte size of the file.
  var bytes: Int64 = 0

  /// Line-by-line content of the source code file.
  var lines: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_DebuggedSourceFiles: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of source code files.
  var sourceFiles: [Tensorboard_DebuggedSourceFile] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_DebugTensorWatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugTensorWatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_name"),
    2: .standard(proto: "output_slot"),
    3: .standard(proto: "debug_ops"),
    4: .standard(proto: "debug_urls"),
    5: .standard(proto: "tolerate_debug_op_creation_failures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.outputSlot) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.debugOps) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.debugUrls) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.tolerateDebugOpCreationFailures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeName.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeName, fieldNumber: 1)
    }
    if self.outputSlot != 0 {
      try visitor.visitSingularInt32Field(value: self.outputSlot, fieldNumber: 2)
    }
    if !self.debugOps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.debugOps, fieldNumber: 3)
    }
    if !self.debugUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.debugUrls, fieldNumber: 4)
    }
    if self.tolerateDebugOpCreationFailures != false {
      try visitor.visitSingularBoolField(value: self.tolerateDebugOpCreationFailures, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_DebugTensorWatch, rhs: Tensorboard_DebugTensorWatch) -> Bool {
    if lhs.nodeName != rhs.nodeName {return false}
    if lhs.outputSlot != rhs.outputSlot {return false}
    if lhs.debugOps != rhs.debugOps {return false}
    if lhs.debugUrls != rhs.debugUrls {return false}
    if lhs.tolerateDebugOpCreationFailures != rhs.tolerateDebugOpCreationFailures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_DebugOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "debug_tensor_watch_opts"),
    10: .standard(proto: "global_step"),
    11: .standard(proto: "reset_disk_byte_usage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.debugTensorWatchOpts) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.globalStep) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.resetDiskByteUsage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debugTensorWatchOpts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.debugTensorWatchOpts, fieldNumber: 4)
    }
    if self.globalStep != 0 {
      try visitor.visitSingularInt64Field(value: self.globalStep, fieldNumber: 10)
    }
    if self.resetDiskByteUsage != false {
      try visitor.visitSingularBoolField(value: self.resetDiskByteUsage, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_DebugOptions, rhs: Tensorboard_DebugOptions) -> Bool {
    if lhs.debugTensorWatchOpts != rhs.debugTensorWatchOpts {return false}
    if lhs.globalStep != rhs.globalStep {return false}
    if lhs.resetDiskByteUsage != rhs.resetDiskByteUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_DebuggedSourceFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebuggedSourceFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .standard(proto: "file_path"),
    3: .standard(proto: "last_modified"),
    4: .same(proto: "bytes"),
    5: .same(proto: "lines"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastModified) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bytes) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.lines) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 2)
    }
    if self.lastModified != 0 {
      try visitor.visitSingularInt64Field(value: self.lastModified, fieldNumber: 3)
    }
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 4)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedStringField(value: self.lines, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_DebuggedSourceFile, rhs: Tensorboard_DebuggedSourceFile) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.lastModified != rhs.lastModified {return false}
    if lhs.bytes != rhs.bytes {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_DebuggedSourceFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebuggedSourceFiles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sourceFiles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sourceFiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_DebuggedSourceFiles, rhs: Tensorboard_DebuggedSourceFiles) -> Bool {
    if lhs.sourceFiles != rhs.sourceFiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
