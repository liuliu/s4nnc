// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/tfprof_log.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _3: SwiftProtobuf.ProtobufAPIVersion_3 {}
  typealias Version = _3
}

/// It specifies the Python callstack that creates an op.
struct Tensorboard_CodeDef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var traces: [Tensorboard_CodeDef.Trace] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Trace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// deprecated by file_id.
    var file: String = String()

    var fileID: Int64 = 0

    var lineno: Int32 = 0

    /// deprecated by function_id.
    var function: String = String()

    var functionID: Int64 = 0

    /// deprecated line_id.
    var line: String = String()

    var lineID: Int64 = 0

    var funcStartLine: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Tensorboard_OpLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// op name.
  var name: String = String()

  /// float_ops is filled by tfprof Python API when called. It requires the
  /// op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
  /// implemented.
  var floatOps: Int64 = 0

  /// User can define extra op type information for an op. This allows the user
  /// to select a group of ops precisely using op_type as a key.
  var types: [String] = []

  /// Used to support tfprof "code" view.
  var codeDef: Tensorboard_CodeDef {
    get {return _codeDef ?? Tensorboard_CodeDef()}
    set {_codeDef = newValue}
  }
  /// Returns true if `codeDef` has been explicitly set.
  var hasCodeDef: Bool {return self._codeDef != nil}
  /// Clears the value of `codeDef`. Subsequent reads from it will return its default value.
  mutating func clearCodeDef() {self._codeDef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _codeDef: Tensorboard_CodeDef? = nil
}

struct Tensorboard_OpLogProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logEntries: [Tensorboard_OpLogEntry] = []

  /// Maps from id of CodeDef file,function,line to its string
  /// In the future can also map other id of other fields to string.
  var idToString: Dictionary<Int64,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A proto representation of the profiler's profile.
/// It allows serialization, shipping around and deserialization of the profiles.
///
/// Please don't depend on the internals of the profile proto.
struct Tensorboard_ProfileProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodes: Dictionary<Int64,Tensorboard_ProfileNode> = [:]

  /// Whether or not has code traces.
  var hasTrace_p: Bool = false

  /// Whether or not the TF device tracer fails to return accelerator
  /// information (which could lead to 0 accelerator execution time).
  var missAcceleratorStream: Bool = false

  /// Traced steps.
  var steps: [Int64] = []

  /// Maps from id of CodeDef file,function,line to its string
  /// In the future can also map other id of other fields to string.
  var idToString: Dictionary<Int64,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_ProfileNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// graph node name.
  var name: String = String()

  /// graph operation type.
  var op: String = String()

  /// A unique id for the node.
  var id: Int64 = 0

  var inputs: Dictionary<Int32,Int64> = [:]

  var inputShapes: Dictionary<Int32,Tensorboard_Tuple> = [:]

  var outputs: Dictionary<Int32,Int64> = [:]

  var outputShapes: Dictionary<Int32,Tensorboard_Tuple> = [:]

  /// A map from source node id to its output index to current node.
  var srcOutputIndex: Dictionary<Int64,Int32> = [:]

  var shape: [Int64] = []

  var opTypes: [String] = []

  var canonicalDevice: String = String()

  var hostDevice: String = String()

  var floatOps: Int64 = 0

  var trace: Tensorboard_CodeDef {
    get {return _trace ?? Tensorboard_CodeDef()}
    set {_trace = newValue}
  }
  /// Returns true if `trace` has been explicitly set.
  var hasTrace: Bool {return self._trace != nil}
  /// Clears the value of `trace`. Subsequent reads from it will return its default value.
  mutating func clearTrace() {self._trace = nil}

  var attrs: Dictionary<String,Tensorboard_AttrValue> = [:]

  var execs: Dictionary<Int64,Tensorboard_ExecProfile> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _trace: Tensorboard_CodeDef? = nil
}

struct Tensorboard_ExecProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Can be larger than 1 if run multiple times in loop.
  var runCount: Int64 = 0

  /// The earliest/latest time including scheduling and execution.
  var allStartMicros: Int64 = 0

  var latestEndMicros: Int64 = 0

  /// device -> vector of {op_start_micros, op_exec_micros} pairs.
  /// accelerator_execs: gpu:id/stream:all -> {op_start_micros, op_exec_micros}
  /// For accelerator, vector size can be larger than 1, multiple kernel fires
  /// or in tf.while_loop.
  var acceleratorExecs: Dictionary<String,Tensorboard_ExecTime> = [:]

  /// cpu_execs: cpu/gpu:id -> {op_start_micros, op_exec_micros}
  /// For cpu, vector size can be larger than 1 if in tf.while_loop.
  var cpuExecs: Dictionary<String,Tensorboard_ExecTime> = [:]

  /// Each entry to memory information of a scheduling of the node.
  /// Normally, there will be multiple entries in while_loop.
  var memoryExecs: [Tensorboard_ExecMemory] = []

  /// The allocation and deallocation times and sizes throughout execution.
  var allocations: [Tensorboard_AllocationRecord] = []

  /// The devices related to this execution.
  var devices: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_ExecTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var times: [Tensorboard_Tuple] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_ExecMemory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the timestamp when the memory information was tracked.
  var memoryMicros: Int64 = 0

  /// NOTE: Please don't depend on the following 4 fields yet. Due to
  /// TensorFlow internal tracing issues, the numbers can be quite wrong.
  /// TODO(xpan): Fix the TensorFlow internal tracing.
  var hostTempBytes: Int64 = 0

  var hostPersistentBytes: Int64 = 0

  var acceleratorTempBytes: Int64 = 0

  var acceleratorPersistentBytes: Int64 = 0

  /// Total bytes requested by the op.
  var requestedBytes: Int64 = 0

  /// Total bytes requested by the op and released before op end.
  var peakBytes: Int64 = 0

  /// Total bytes requested by the op and not released after op end.
  var residualBytes: Int64 = 0

  /// Total bytes output by the op (not necessarily requested by the op).
  var outputBytes: Int64 = 0

  /// The total number of bytes currently allocated by the allocator if >0.
  var allocatorBytesInUse: Int64 = 0

  /// The memory of each output of the operation.
  var outputMemory: Dictionary<Int32,Tensorboard_Memory> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_Tuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var int64Values: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tensorboard_Memory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytes: Int64 = 0

  var ptr: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tensorboard_CodeDef: @unchecked Sendable {}
extension Tensorboard_CodeDef.Trace: @unchecked Sendable {}
extension Tensorboard_OpLogEntry: @unchecked Sendable {}
extension Tensorboard_OpLogProto: @unchecked Sendable {}
extension Tensorboard_ProfileProto: @unchecked Sendable {}
extension Tensorboard_ProfileNode: @unchecked Sendable {}
extension Tensorboard_ExecProfile: @unchecked Sendable {}
extension Tensorboard_ExecTime: @unchecked Sendable {}
extension Tensorboard_ExecMemory: @unchecked Sendable {}
extension Tensorboard_Tuple: @unchecked Sendable {}
extension Tensorboard_Memory: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_CodeDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CodeDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "traces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.traces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CodeDef, rhs: Tensorboard_CodeDef) -> Bool {
    if lhs.traces != rhs.traces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_CodeDef.Trace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_CodeDef.protoMessageName + ".Trace"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    6: .standard(proto: "file_id"),
    2: .same(proto: "lineno"),
    3: .same(proto: "function"),
    7: .standard(proto: "function_id"),
    4: .same(proto: "line"),
    8: .standard(proto: "line_id"),
    5: .standard(proto: "func_start_line"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.lineno) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.function) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.line) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.funcStartLine) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.fileID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.functionID) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.lineID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 1)
    }
    if self.lineno != 0 {
      try visitor.visitSingularInt32Field(value: self.lineno, fieldNumber: 2)
    }
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 3)
    }
    if !self.line.isEmpty {
      try visitor.visitSingularStringField(value: self.line, fieldNumber: 4)
    }
    if self.funcStartLine != 0 {
      try visitor.visitSingularInt32Field(value: self.funcStartLine, fieldNumber: 5)
    }
    if self.fileID != 0 {
      try visitor.visitSingularInt64Field(value: self.fileID, fieldNumber: 6)
    }
    if self.functionID != 0 {
      try visitor.visitSingularInt64Field(value: self.functionID, fieldNumber: 7)
    }
    if self.lineID != 0 {
      try visitor.visitSingularInt64Field(value: self.lineID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_CodeDef.Trace, rhs: Tensorboard_CodeDef.Trace) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs.fileID != rhs.fileID {return false}
    if lhs.lineno != rhs.lineno {return false}
    if lhs.function != rhs.function {return false}
    if lhs.functionID != rhs.functionID {return false}
    if lhs.line != rhs.line {return false}
    if lhs.lineID != rhs.lineID {return false}
    if lhs.funcStartLine != rhs.funcStartLine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_OpLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpLogEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "float_ops"),
    3: .same(proto: "types"),
    4: .standard(proto: "code_def"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.floatOps) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._codeDef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.floatOps != 0 {
      try visitor.visitSingularInt64Field(value: self.floatOps, fieldNumber: 2)
    }
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 3)
    }
    try { if let v = self._codeDef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpLogEntry, rhs: Tensorboard_OpLogEntry) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.floatOps != rhs.floatOps {return false}
    if lhs.types != rhs.types {return false}
    if lhs._codeDef != rhs._codeDef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_OpLogProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpLogProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entries"),
    2: .standard(proto: "id_to_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logEntries) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: &self.idToString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logEntries, fieldNumber: 1)
    }
    if !self.idToString.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: self.idToString, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpLogProto, rhs: Tensorboard_OpLogProto) -> Bool {
    if lhs.logEntries != rhs.logEntries {return false}
    if lhs.idToString != rhs.idToString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_ProfileProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "has_trace"),
    5: .standard(proto: "miss_accelerator_stream"),
    3: .same(proto: "steps"),
    4: .standard(proto: "id_to_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorboard_ProfileNode>.self, value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasTrace_p) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.steps) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: &self.idToString) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.missAcceleratorStream) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorboard_ProfileNode>.self, value: self.nodes, fieldNumber: 1)
    }
    if self.hasTrace_p != false {
      try visitor.visitSingularBoolField(value: self.hasTrace_p, fieldNumber: 2)
    }
    if !self.steps.isEmpty {
      try visitor.visitPackedInt64Field(value: self.steps, fieldNumber: 3)
    }
    if !self.idToString.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: self.idToString, fieldNumber: 4)
    }
    if self.missAcceleratorStream != false {
      try visitor.visitSingularBoolField(value: self.missAcceleratorStream, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_ProfileProto, rhs: Tensorboard_ProfileProto) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.hasTrace_p != rhs.hasTrace_p {return false}
    if lhs.missAcceleratorStream != rhs.missAcceleratorStream {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.idToString != rhs.idToString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_ProfileNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProfileNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    9: .same(proto: "op"),
    13: .same(proto: "id"),
    2: .same(proto: "inputs"),
    16: .standard(proto: "input_shapes"),
    3: .same(proto: "outputs"),
    15: .standard(proto: "output_shapes"),
    14: .standard(proto: "src_output_index"),
    4: .same(proto: "shape"),
    5: .standard(proto: "op_types"),
    6: .standard(proto: "canonical_device"),
    7: .standard(proto: "host_device"),
    8: .standard(proto: "float_ops"),
    10: .same(proto: "trace"),
    11: .same(proto: "attrs"),
    12: .same(proto: "execs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: &self.inputs) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: &self.outputs) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.shape) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.opTypes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.canonicalDevice) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.hostDevice) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.floatOps) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.op) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._trace) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_AttrValue>.self, value: &self.attrs) }()
      case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorboard_ExecProfile>.self, value: &self.execs) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 14: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: &self.srcOutputIndex) }()
      case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorboard_Tuple>.self, value: &self.outputShapes) }()
      case 16: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorboard_Tuple>.self, value: &self.inputShapes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: self.inputs, fieldNumber: 2)
    }
    if !self.outputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: self.outputs, fieldNumber: 3)
    }
    if !self.shape.isEmpty {
      try visitor.visitPackedInt64Field(value: self.shape, fieldNumber: 4)
    }
    if !self.opTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.opTypes, fieldNumber: 5)
    }
    if !self.canonicalDevice.isEmpty {
      try visitor.visitSingularStringField(value: self.canonicalDevice, fieldNumber: 6)
    }
    if !self.hostDevice.isEmpty {
      try visitor.visitSingularStringField(value: self.hostDevice, fieldNumber: 7)
    }
    if self.floatOps != 0 {
      try visitor.visitSingularInt64Field(value: self.floatOps, fieldNumber: 8)
    }
    if !self.op.isEmpty {
      try visitor.visitSingularStringField(value: self.op, fieldNumber: 9)
    }
    try { if let v = self._trace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.attrs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_AttrValue>.self, value: self.attrs, fieldNumber: 11)
    }
    if !self.execs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorboard_ExecProfile>.self, value: self.execs, fieldNumber: 12)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 13)
    }
    if !self.srcOutputIndex.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: self.srcOutputIndex, fieldNumber: 14)
    }
    if !self.outputShapes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorboard_Tuple>.self, value: self.outputShapes, fieldNumber: 15)
    }
    if !self.inputShapes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorboard_Tuple>.self, value: self.inputShapes, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_ProfileNode, rhs: Tensorboard_ProfileNode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.op != rhs.op {return false}
    if lhs.id != rhs.id {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.inputShapes != rhs.inputShapes {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.outputShapes != rhs.outputShapes {return false}
    if lhs.srcOutputIndex != rhs.srcOutputIndex {return false}
    if lhs.shape != rhs.shape {return false}
    if lhs.opTypes != rhs.opTypes {return false}
    if lhs.canonicalDevice != rhs.canonicalDevice {return false}
    if lhs.hostDevice != rhs.hostDevice {return false}
    if lhs.floatOps != rhs.floatOps {return false}
    if lhs._trace != rhs._trace {return false}
    if lhs.attrs != rhs.attrs {return false}
    if lhs.execs != rhs.execs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_ExecProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "run_count"),
    2: .standard(proto: "all_start_micros"),
    3: .standard(proto: "latest_end_micros"),
    4: .standard(proto: "accelerator_execs"),
    5: .standard(proto: "cpu_execs"),
    7: .standard(proto: "memory_execs"),
    11: .same(proto: "allocations"),
    6: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.runCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.allStartMicros) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.latestEndMicros) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_ExecTime>.self, value: &self.acceleratorExecs) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_ExecTime>.self, value: &self.cpuExecs) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.devices) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.memoryExecs) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.allocations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.runCount != 0 {
      try visitor.visitSingularInt64Field(value: self.runCount, fieldNumber: 1)
    }
    if self.allStartMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.allStartMicros, fieldNumber: 2)
    }
    if self.latestEndMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.latestEndMicros, fieldNumber: 3)
    }
    if !self.acceleratorExecs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_ExecTime>.self, value: self.acceleratorExecs, fieldNumber: 4)
    }
    if !self.cpuExecs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_ExecTime>.self, value: self.cpuExecs, fieldNumber: 5)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedStringField(value: self.devices, fieldNumber: 6)
    }
    if !self.memoryExecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memoryExecs, fieldNumber: 7)
    }
    if !self.allocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allocations, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_ExecProfile, rhs: Tensorboard_ExecProfile) -> Bool {
    if lhs.runCount != rhs.runCount {return false}
    if lhs.allStartMicros != rhs.allStartMicros {return false}
    if lhs.latestEndMicros != rhs.latestEndMicros {return false}
    if lhs.acceleratorExecs != rhs.acceleratorExecs {return false}
    if lhs.cpuExecs != rhs.cpuExecs {return false}
    if lhs.memoryExecs != rhs.memoryExecs {return false}
    if lhs.allocations != rhs.allocations {return false}
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_ExecTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "times"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.times) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.times.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.times, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_ExecTime, rhs: Tensorboard_ExecTime) -> Bool {
    if lhs.times != rhs.times {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_ExecMemory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecMemory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "memory_micros"),
    2: .standard(proto: "host_temp_bytes"),
    3: .standard(proto: "host_persistent_bytes"),
    4: .standard(proto: "accelerator_temp_bytes"),
    5: .standard(proto: "accelerator_persistent_bytes"),
    6: .standard(proto: "requested_bytes"),
    7: .standard(proto: "peak_bytes"),
    8: .standard(proto: "residual_bytes"),
    9: .standard(proto: "output_bytes"),
    10: .standard(proto: "allocator_bytes_in_use"),
    11: .standard(proto: "output_memory"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.memoryMicros) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.hostTempBytes) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.hostPersistentBytes) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.acceleratorTempBytes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.acceleratorPersistentBytes) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.requestedBytes) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.peakBytes) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.residualBytes) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.outputBytes) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.allocatorBytesInUse) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorboard_Memory>.self, value: &self.outputMemory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memoryMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.memoryMicros, fieldNumber: 1)
    }
    if self.hostTempBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.hostTempBytes, fieldNumber: 2)
    }
    if self.hostPersistentBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.hostPersistentBytes, fieldNumber: 3)
    }
    if self.acceleratorTempBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.acceleratorTempBytes, fieldNumber: 4)
    }
    if self.acceleratorPersistentBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.acceleratorPersistentBytes, fieldNumber: 5)
    }
    if self.requestedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.requestedBytes, fieldNumber: 6)
    }
    if self.peakBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.peakBytes, fieldNumber: 7)
    }
    if self.residualBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.residualBytes, fieldNumber: 8)
    }
    if self.outputBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.outputBytes, fieldNumber: 9)
    }
    if self.allocatorBytesInUse != 0 {
      try visitor.visitSingularInt64Field(value: self.allocatorBytesInUse, fieldNumber: 10)
    }
    if !self.outputMemory.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorboard_Memory>.self, value: self.outputMemory, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_ExecMemory, rhs: Tensorboard_ExecMemory) -> Bool {
    if lhs.memoryMicros != rhs.memoryMicros {return false}
    if lhs.hostTempBytes != rhs.hostTempBytes {return false}
    if lhs.hostPersistentBytes != rhs.hostPersistentBytes {return false}
    if lhs.acceleratorTempBytes != rhs.acceleratorTempBytes {return false}
    if lhs.acceleratorPersistentBytes != rhs.acceleratorPersistentBytes {return false}
    if lhs.requestedBytes != rhs.requestedBytes {return false}
    if lhs.peakBytes != rhs.peakBytes {return false}
    if lhs.residualBytes != rhs.residualBytes {return false}
    if lhs.outputBytes != rhs.outputBytes {return false}
    if lhs.allocatorBytesInUse != rhs.allocatorBytesInUse {return false}
    if lhs.outputMemory != rhs.outputMemory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_Tuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tuple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "int64_values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.int64Values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.int64Values.isEmpty {
      try visitor.visitPackedInt64Field(value: self.int64Values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_Tuple, rhs: Tensorboard_Tuple) -> Bool {
    if lhs.int64Values != rhs.int64Values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_Memory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Memory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
    2: .same(proto: "ptr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.bytes) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.ptr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 1)
    }
    if self.ptr != 0 {
      try visitor.visitSingularUInt64Field(value: self.ptr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_Memory, rhs: Tensorboard_Memory) -> Bool {
    if lhs.bytes != rhs.bytes {return false}
    if lhs.ptr != rhs.ptr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
