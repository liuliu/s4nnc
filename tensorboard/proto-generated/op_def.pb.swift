// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/op_def.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines an operation. A NodeDef in a GraphDef specifies an Op by
/// using the "op" field which should match the name of a OpDef.
/// DISABLED.IfChange
struct Tensorboard_OpDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Op names starting with an underscore are reserved for internal use.
  /// Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9>_]*".
  var name: String = String()

  /// Description of the input(s).
  var inputArg: [Tensorboard_OpDef.ArgDef] = []

  /// Description of the output(s).
  var outputArg: [Tensorboard_OpDef.ArgDef] = []

  /// Named control outputs for this operation. Useful only for composite
  /// operations (i.e. functions) which want to name different control outputs.
  var controlOutput: [String] = []

  var attr: [Tensorboard_OpDef.AttrDef] = []

  /// Optional deprecation based on GraphDef versions.
  var deprecation: Tensorboard_OpDeprecation {
    get {return _deprecation ?? Tensorboard_OpDeprecation()}
    set {_deprecation = newValue}
  }
  /// Returns true if `deprecation` has been explicitly set.
  var hasDeprecation: Bool {return self._deprecation != nil}
  /// Clears the value of `deprecation`. Subsequent reads from it will return its default value.
  mutating func clearDeprecation() {self._deprecation = nil}

  /// One-line human-readable description of what the Op does.
  var summary: String = String()

  /// Additional, longer human-readable description of what the Op does.
  var description_p: String = String()

  /// True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
  var isCommutative: Bool = false

  /// If is_aggregate is true, then this operation accepts N >= 2
  /// inputs and produces 1 output all of the same type.  Should be
  /// associative and commutative, and produce output with the same
  /// shape as the input.  The optimizer may replace an aggregate op
  /// taking input from multiple devices with a tree of aggregate ops
  /// that aggregate locally within each device (and possibly within
  /// groups of nearby devices) before communicating.
  /// TODO(josh11b): Implement that optimization.
  var isAggregate: Bool = false

  /// Ops are marked as stateful if their behavior depends on some state beyond
  /// their input tensors (e.g. variable reading op) or if they have
  /// a side-effect (e.g. printing or asserting ops). Equivalently, stateless ops
  /// must always produce the same output for the same input and have
  /// no side-effects.
  ///
  /// By default Ops may be moved between devices.  Stateful ops should
  /// either not be moved, or should only be moved if that state can also
  /// be moved (e.g. via some sort of save / restore).
  /// Stateful ops are guaranteed to never be optimized away by Common
  /// Subexpression Elimination (CSE).
  var isStateful: Bool = false

  /// By default, all inputs to an Op must be initialized Tensors.  Ops
  /// that may initialize tensors for the first time should set this
  /// field to true, to allow the Op to take an uninitialized Tensor as
  /// input.
  var allowsUninitializedInput: Bool = false

  /// Indicates whether the op implementation uses distributed communication.
  /// If True, the op is allowed to return errors for network disconnection and
  /// trigger TF network failure handling logics.
  var isDistributedCommunication: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// For describing inputs and outputs.
  struct ArgDef: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*".
    var name: String = String()

    /// Human readable description.
    var description_p: String = String()

    /// Describes the type of one or more tensors that are accepted/produced
    /// by this input/output arg.  The only legal combinations are:
    /// * For a single tensor: either the "type" field is set or the
    ///   "type_attr" field is set to the name of an attr with type "type".
    /// * For a sequence of tensors with the same type: the "number_attr"
    ///   field will be set to the name of an attr with type "int", and
    ///   either the "type" or "type_attr" field will be set as for
    ///   single tensors.
    /// * For a sequence of tensors, the "type_list_attr" field will be set
    ///   to the name of an attr with type "list(type)".
    var type: Tensorboard_DataType = .dtInvalid

    /// if specified, attr must have type "type"
    var typeAttr: String = String()

    /// if specified, attr must have type "int"
    var numberAttr: String = String()

    /// If specified, attr must have type "list(type)", and none of
    /// type, type_attr, and number_attr may be specified.
    var typeListAttr: String = String()

    /// The handle data for resource inputs.
    var handleData: [Tensorboard_ResourceHandleProto.DtypeAndShape] = []

    /// For inputs: if true, the inputs are required to be refs.
    ///   By default, inputs can be either refs or non-refs.
    /// For outputs: if true, outputs are refs, otherwise they are not.
    var isRef: Bool = false

    /// Experimental. Full type declaration for this argument.
    /// The full type specification combines type, type_attr, type_list_attr,
    /// etc. into a unified representation.
    /// This declaration may contain non-concrete types (for example,
    /// Tensor<TypeVar<'T'>> is a valid type declaration.
    ///
    /// Note: this is a transient field. The long-term aim is to represent the
    /// entire OpDef as a single type: a callable. In that context, this field is
    /// just the type of a single argument.
    var experimentalFullType: Tensorboard_FullTypeDef {
      get {return _experimentalFullType ?? Tensorboard_FullTypeDef()}
      set {_experimentalFullType = newValue}
    }
    /// Returns true if `experimentalFullType` has been explicitly set.
    var hasExperimentalFullType: Bool {return self._experimentalFullType != nil}
    /// Clears the value of `experimentalFullType`. Subsequent reads from it will return its default value.
    mutating func clearExperimentalFullType() {self._experimentalFullType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _experimentalFullType: Tensorboard_FullTypeDef? = nil
  }

  /// Description of the graph-construction-time configuration of this
  /// Op.  That is to say, this describes the attr fields that will
  /// be specified in the NodeDef.
  struct AttrDef: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A descriptive name for the argument.  May be used, e.g. by the
    /// Python client, as a keyword argument name, and so should match
    /// the regexp "[a-z][a-z0-9_]+".
    var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    /// One of the type names from attr_value.proto ("string", "list(string)",
    /// "int", etc.).
    var type: String {
      get {return _storage._type}
      set {_uniqueStorage()._type = newValue}
    }

    /// A reasonable default for this attribute if the user does not supply
    /// a value.  If not specified, the user must supply a value.
    var defaultValue: Tensorboard_AttrValue {
      get {return _storage._defaultValue ?? Tensorboard_AttrValue()}
      set {_uniqueStorage()._defaultValue = newValue}
    }
    /// Returns true if `defaultValue` has been explicitly set.
    var hasDefaultValue: Bool {return _storage._defaultValue != nil}
    /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
    mutating func clearDefaultValue() {_uniqueStorage()._defaultValue = nil}

    /// Human-readable description.
    var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    /// For type == "int", this is a minimum value.  For "list(___)"
    /// types, this is the minimum length.
    var hasMinimum_p: Bool {
      get {return _storage._hasMinimum_p}
      set {_uniqueStorage()._hasMinimum_p = newValue}
    }

    var minimum: Int64 {
      get {return _storage._minimum}
      set {_uniqueStorage()._minimum = newValue}
    }

    /// The set of allowed values.  Has type that is the "list" version
    /// of the "type" field above (uses the "list" field of AttrValue).
    /// If type == "type" or "list(type)" above, then the "type" field
    /// of "allowed_values.list" has the set of allowed DataTypes.
    /// If type == "string" or "list(string)", then the "s" field of
    /// "allowed_values.list" has the set of allowed strings.
    var allowedValues: Tensorboard_AttrValue {
      get {return _storage._allowedValues ?? Tensorboard_AttrValue()}
      set {_uniqueStorage()._allowedValues = newValue}
    }
    /// Returns true if `allowedValues` has been explicitly set.
    var hasAllowedValues: Bool {return _storage._allowedValues != nil}
    /// Clears the value of `allowedValues`. Subsequent reads from it will return its default value.
    mutating func clearAllowedValues() {_uniqueStorage()._allowedValues = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _deprecation: Tensorboard_OpDeprecation? = nil
}

/// Information about version-dependent deprecation of an op
struct Tensorboard_OpDeprecation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// First GraphDef version at which the op is disallowed.
  var version: Int32 = 0

  /// Explanation of why it was deprecated and what to use instead.
  var explanation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A collection of OpDefs
struct Tensorboard_OpList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var op: [Tensorboard_OpDef] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_OpDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "input_arg"),
    3: .standard(proto: "output_arg"),
    20: .standard(proto: "control_output"),
    4: .same(proto: "attr"),
    8: .same(proto: "deprecation"),
    5: .same(proto: "summary"),
    6: .same(proto: "description"),
    18: .standard(proto: "is_commutative"),
    16: .standard(proto: "is_aggregate"),
    17: .standard(proto: "is_stateful"),
    19: .standard(proto: "allows_uninitialized_input"),
    21: .standard(proto: "is_distributed_communication"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputArg) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputArg) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._deprecation) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.isAggregate) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.isStateful) }()
      case 18: try { try decoder.decodeSingularBoolField(value: &self.isCommutative) }()
      case 19: try { try decoder.decodeSingularBoolField(value: &self.allowsUninitializedInput) }()
      case 20: try { try decoder.decodeRepeatedStringField(value: &self.controlOutput) }()
      case 21: try { try decoder.decodeSingularBoolField(value: &self.isDistributedCommunication) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.inputArg.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputArg, fieldNumber: 2)
    }
    if !self.outputArg.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputArg, fieldNumber: 3)
    }
    if !self.attr.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attr, fieldNumber: 4)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try { if let v = self._deprecation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.isAggregate != false {
      try visitor.visitSingularBoolField(value: self.isAggregate, fieldNumber: 16)
    }
    if self.isStateful != false {
      try visitor.visitSingularBoolField(value: self.isStateful, fieldNumber: 17)
    }
    if self.isCommutative != false {
      try visitor.visitSingularBoolField(value: self.isCommutative, fieldNumber: 18)
    }
    if self.allowsUninitializedInput != false {
      try visitor.visitSingularBoolField(value: self.allowsUninitializedInput, fieldNumber: 19)
    }
    if !self.controlOutput.isEmpty {
      try visitor.visitRepeatedStringField(value: self.controlOutput, fieldNumber: 20)
    }
    if self.isDistributedCommunication != false {
      try visitor.visitSingularBoolField(value: self.isDistributedCommunication, fieldNumber: 21)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpDef, rhs: Tensorboard_OpDef) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.inputArg != rhs.inputArg {return false}
    if lhs.outputArg != rhs.outputArg {return false}
    if lhs.controlOutput != rhs.controlOutput {return false}
    if lhs.attr != rhs.attr {return false}
    if lhs._deprecation != rhs._deprecation {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.isCommutative != rhs.isCommutative {return false}
    if lhs.isAggregate != rhs.isAggregate {return false}
    if lhs.isStateful != rhs.isStateful {return false}
    if lhs.allowsUninitializedInput != rhs.allowsUninitializedInput {return false}
    if lhs.isDistributedCommunication != rhs.isDistributedCommunication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_OpDef.ArgDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_OpDef.protoMessageName + ".ArgDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "type"),
    4: .standard(proto: "type_attr"),
    5: .standard(proto: "number_attr"),
    6: .standard(proto: "type_list_attr"),
    7: .standard(proto: "handle_data"),
    16: .standard(proto: "is_ref"),
    17: .standard(proto: "experimental_full_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.typeAttr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.numberAttr) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.typeListAttr) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.handleData) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.isRef) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._experimentalFullType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.type != .dtInvalid {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.typeAttr.isEmpty {
      try visitor.visitSingularStringField(value: self.typeAttr, fieldNumber: 4)
    }
    if !self.numberAttr.isEmpty {
      try visitor.visitSingularStringField(value: self.numberAttr, fieldNumber: 5)
    }
    if !self.typeListAttr.isEmpty {
      try visitor.visitSingularStringField(value: self.typeListAttr, fieldNumber: 6)
    }
    if !self.handleData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.handleData, fieldNumber: 7)
    }
    if self.isRef != false {
      try visitor.visitSingularBoolField(value: self.isRef, fieldNumber: 16)
    }
    try { if let v = self._experimentalFullType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpDef.ArgDef, rhs: Tensorboard_OpDef.ArgDef) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.type != rhs.type {return false}
    if lhs.typeAttr != rhs.typeAttr {return false}
    if lhs.numberAttr != rhs.numberAttr {return false}
    if lhs.typeListAttr != rhs.typeListAttr {return false}
    if lhs.handleData != rhs.handleData {return false}
    if lhs.isRef != rhs.isRef {return false}
    if lhs._experimentalFullType != rhs._experimentalFullType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_OpDef.AttrDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tensorboard_OpDef.protoMessageName + ".AttrDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .standard(proto: "default_value"),
    4: .same(proto: "description"),
    5: .standard(proto: "has_minimum"),
    6: .same(proto: "minimum"),
    7: .standard(proto: "allowed_values"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _type: String = String()
    var _defaultValue: Tensorboard_AttrValue? = nil
    var _description_p: String = String()
    var _hasMinimum_p: Bool = false
    var _minimum: Int64 = 0
    var _allowedValues: Tensorboard_AttrValue? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _type = source._type
      _defaultValue = source._defaultValue
      _description_p = source._description_p
      _hasMinimum_p = source._hasMinimum_p
      _minimum = source._minimum
      _allowedValues = source._allowedValues
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._defaultValue) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._hasMinimum_p) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._minimum) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._allowedValues) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 2)
      }
      try { if let v = _storage._defaultValue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      if _storage._hasMinimum_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasMinimum_p, fieldNumber: 5)
      }
      if _storage._minimum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._minimum, fieldNumber: 6)
      }
      try { if let v = _storage._allowedValues {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpDef.AttrDef, rhs: Tensorboard_OpDef.AttrDef) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._defaultValue != rhs_storage._defaultValue {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._hasMinimum_p != rhs_storage._hasMinimum_p {return false}
        if _storage._minimum != rhs_storage._minimum {return false}
        if _storage._allowedValues != rhs_storage._allowedValues {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_OpDeprecation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpDeprecation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "explanation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpDeprecation, rhs: Tensorboard_OpDeprecation) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_OpList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.op) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.op.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.op, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_OpList, rhs: Tensorboard_OpList) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
