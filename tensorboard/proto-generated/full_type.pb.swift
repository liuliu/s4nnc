// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/full_type.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DISABLED.IfChange
/// Experimental. Represents the complete type information of a TensorFlow value.
enum Tensorboard_FullTypeId: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// The default represents an uninitialized values.
  case tftUnset // = 0

  /// Type variables may serve as placeholder for any other type ID in type
  /// templates.
  ///
  /// Examples:
  ///   TFT_DATASET[TFT_VAR["T"]] is a Dataset returning a type indicated by "T".
  ///   TFT_TENSOR[TFT_VAR["T"]] is a Tensor of n element type indicated by "T".
  ///   TFT_TENSOR[TFT_VAR["T"]], TFT_TENSOR[TFT_VAR["T"]] are two tensors of
  ///     identical element types.
  ///   TFT_TENSOR[TFT_VAR["P"]], TFT_TENSOR[TFT_VAR["Q"]] are two tensors of
  ///     independent element types.
  case tftVar // = 1

  /// Wildcard type. Describes a parameter of unknown type. In TensorFlow, that
  /// can mean either a "Top" type (accepts any type), or a dynamically typed
  /// object whose type is unknown in context.
  /// Important: "unknown" does not necessarily mean undeterminable!
  case tftAny // = 2

  /// The algebraic product type. This is an algebraic type that may be used just
  /// for logical grouping. Not to confused with TFT_TUPLE which describes a
  /// concrete object of several elements.
  ///
  /// Example:
  ///   TFT_DATASET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]]]
  ///     is a Dataset producing two tensors, an integer one and a float one.
  case tftProduct // = 3

  /// Represents a named field, with the name stored in the attribute.
  ///
  /// Parametrization:
  ///   TFT_NAMED[<type>]{<name>}
  ///   * <type> is the type of the field
  ///   * <name> is the field name, as string (thpugh can theoretically be an int
  ///     as well)
  ///
  /// Example:
  ///   TFT_RECORD[
  ///     TFT_NAMED[TFT_TENSOR[TFT_INT32]]{'foo'},
  ///     TFT_NAMED[TFT_TENSOR[TFT_FLOAT32]]{'bar'},
  ///   ]
  ///     is a structure with two fields, an int tensor "foo" and a float tensor
  ///     "bar".
  case tftNamed // = 4

  /// Template definition. Expands the variables by repeating a template as
  /// arguments of container.
  ///
  /// Parametrization:
  ///   TFT_FOR_EACH[<container_type>, <template>, <expansions>]
  ///   * <container_type> is the type of the container that the template will be
  ///     expanded into
  ///   * <template> is any type definition that potentially contains type
  ///     variables
  ///   * <expansions> is a TFT_VAR and may include more types in the future
  ///
  /// Example:
  ///   TFT_FOR_EACH[
  ///         TFT_PRODUCT,
  ///         TFT_TENSOR[TFT_VAR["t"]],
  ///         TFT_VAR["t"]
  ///     ]
  ///     will substitute a T = TFT_INT32 to TFT_PRODUCT[TFT_TENSOR[TFT_INT32]]
  ///     and a T = (TFT_INT32, TFT_INT64) to
  ///     TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_INT64]].
  case tftForEach // = 20

  /// Callable types describe functions and ops.
  ///
  /// Parametrization:
  ///   TFT_CALLABLE[<arg type>, <return type>]
  ///   * <arg type> is the type of the arguments; TFT_PRODUCT represents
  ///   multiple
  ///     arguments.
  ///   * <return type> is the return type; TFT_PRODUCT represents multiple
  ///     return values (that means that callables returning multiple things
  ///     don't necessarily return a single tuple).
  ///
  /// Example:
  ///   TFT_CALLABLE[
  ///     TFT_ANY,
  ///     TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]],
  ///   ]
  ///     is a callable with unspecified (for now) input arguments, and
  ///     two return values of type tensor.
  case tftCallable // = 100

  /// The usual Tensor. This is a parametric type.
  ///
  /// Parametrization:
  ///   TFT_TENSOR[<element type>, <shape type>]
  ///   * <element type> is currently limited to one of the element types
  ///     defined below.
  ///   * <shape type> is not yet defined, and may only be TFT_UNKNOWN for now.
  ///
  /// A TFT_SHAPE type will be defined in the future.
  ///
  /// Example:
  ///   TFT_TENSOR[TFT_INT32, TFT_UNKNOWN]
  ///     is a Tensor of int32 element type and unknown shape.
  ///
  /// TODO(mdan): Define TFT_SHAPE and add more examples.
  case tftTensor // = 1000

  /// Array (or tensorflow::TensorList in the variant type registry).
  /// Note: this is not to be confused with the deprecated `TensorArray*` ops
  /// which are not supported by FullType.
  /// This type represents a random-access list whose elements can be
  /// described by a single type. Although immutable, Array is expected to
  /// support efficient mutation semantics (i.e. element update) in the
  /// user-facing API.
  /// The element type may be generic or even TFT_ANY for a heterogenous list.
  ///
  /// Parametrization:
  ///   TFT_ARRAY[<element type>]
  ///   * <element type> may be any concrete type.
  ///
  /// Examples:
  ///   TFT_ARRAY[TFT_TENSOR[TFT_INT32]] is a TensorArray holding int32 Tensors
  ///     of any shape.
  ///   TFT_ARRAY[TFT_TENSOR[TFT_UNKNOWN]] is a TensorArray holding Tensors of
  ///     mixed element types.
  ///   TFT_ARRAY[TFT_UNKNOWN] is a TensorArray holding any element type.
  ///   TFT_ARRAY[] is equivalent to TFT_ARRAY[TFT_UNKNOWN].
  ///   TFT_ARRAY[TFT_ARRAY[]] is an array or arrays (of unknown types).
  case tftArray // = 1001

  /// Optional (or tensorflow::OptionalVariant in the variant type registry).
  /// This type represents a value that may either hold an element of a single
  /// specified type, or nothing at all.
  ///
  /// Parametrization:
  ///   TFT_OPTIONAL[<element type>]
  ///   * <element type> may be any concrete type.
  ///
  /// Examples:
  ///   TFT_OPTIONAL[TFT_TENSOR[TFT_INT32]] is an Optional holding an int32
  ///     Tensor of any shape.
  case tftOptional // = 1002

  /// Literal types describe compile-time constant values.
  /// Literal types may also participate in dependent types.
  ///
  /// Parametrization:
  ///   TFT_LITERAL[<value type>]{<value>}
  ///   * <value type> may be any concrete type compatible that can hold <value>
  ///   * <value> is the type's attribute, and holds the actual literal value
  ///
  /// Examples:
  ///   TFT_LITERAL[TFT_INT32]{1} is the compile-time constant 1.
  case tftLiteral // = 1003

  /// The bool element type.
  /// TODO(mdan): Quantized types, legacy representations (e.g. ref)
  case tftBool // = 200

  /// Integer element types.
  case tftUint8 // = 201
  case tftUint16 // = 202
  case tftUint32 // = 203
  case tftUint64 // = 204
  case tftInt8 // = 205
  case tftInt16 // = 206
  case tftInt32 // = 207
  case tftInt64 // = 208

  /// Floating-point element types.
  case tftHalf // = 209
  case tftFloat // = 210
  case tftDouble // = 211
  case tftBfloat16 // = 215

  /// Complex element types.
  /// TODO(mdan): Represent as TFT_COMPLEX[TFT_DOUBLE] instead?
  case tftComplex64 // = 212
  case tftComplex128 // = 213

  /// The string element type.
  case tftString // = 214

  /// Datasets created by tf.data ops and APIs. Datasets have generator/iterable
  /// semantics, that is, one can construct an iterator from them. Like
  /// Array, they are considered to return elements that can be described
  /// by a single type. Unlike Array, they do not support random access or
  /// mutation, and can potentially produce an infinite number of elements.
  /// A datasets can produce logical structures (e.g. multiple elements). This
  /// is expressed using TFT_PRODUCT.
  ///
  ///
  /// Parametrization: TFT_ARRAY[<element type>].
  ///   * <element type> may be a concrete type or a type symbol. It represents
  ///     the data type of the elements produced by the dataset.
  ///
  /// Examples:
  ///   TFT_DATSET[TFT_TENSOR[TFT_INT32]] is a Dataset producing single int32
  ///     Tensors of unknown shape.
  ///   TFT_DATSET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT32]] is
  ///     a Dataset producing pairs of Tensors, one integer and one float.
  /// Note: The high ID number is to prepare for the eventuality that Datasets
  /// will be supported by user types in the future.
  case tftDataset // = 10102

  /// A ragged tensor created by tf.ragged ops and APIs.
  ///
  /// Parametrization: TFT_RAGGED[<element_type>].
  case tftRagged // = 10103

  /// A mutex lock tensor, produced by tf.raw_ops.MutexLock.
  /// Unlike strict execution models, where ownership of a lock is denoted by
  /// "running after the lock has been acquired", in non-strict mode, lock
  /// ownership is in the true sense: "the op argument representing the lock is
  /// available".
  /// Mutex locks are the dynamic counterpart of control dependencies.
  /// TODO(mdan): Properly document this thing.
  ///
  /// Parametrization: TFT_MUTEX_LOCK[].
  case tftMutexLock // = 10202

  /// The equivalent of a Tensor with DT_VARIANT dtype, kept here to simplify
  /// translation. This type should not normally appear after type inference.
  /// Note that LEGACY_VARIANT != ANY: TENSOR[INT32] is a subtype of ANY, but is
  /// not a subtype of LEGACY_VARIANT.
  case tftLegacyVariant // = 10203
  case UNRECOGNIZED(Int)

  init() {
    self = .tftUnset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tftUnset
    case 1: self = .tftVar
    case 2: self = .tftAny
    case 3: self = .tftProduct
    case 4: self = .tftNamed
    case 20: self = .tftForEach
    case 100: self = .tftCallable
    case 200: self = .tftBool
    case 201: self = .tftUint8
    case 202: self = .tftUint16
    case 203: self = .tftUint32
    case 204: self = .tftUint64
    case 205: self = .tftInt8
    case 206: self = .tftInt16
    case 207: self = .tftInt32
    case 208: self = .tftInt64
    case 209: self = .tftHalf
    case 210: self = .tftFloat
    case 211: self = .tftDouble
    case 212: self = .tftComplex64
    case 213: self = .tftComplex128
    case 214: self = .tftString
    case 215: self = .tftBfloat16
    case 1000: self = .tftTensor
    case 1001: self = .tftArray
    case 1002: self = .tftOptional
    case 1003: self = .tftLiteral
    case 10102: self = .tftDataset
    case 10103: self = .tftRagged
    case 10202: self = .tftMutexLock
    case 10203: self = .tftLegacyVariant
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tftUnset: return 0
    case .tftVar: return 1
    case .tftAny: return 2
    case .tftProduct: return 3
    case .tftNamed: return 4
    case .tftForEach: return 20
    case .tftCallable: return 100
    case .tftBool: return 200
    case .tftUint8: return 201
    case .tftUint16: return 202
    case .tftUint32: return 203
    case .tftUint64: return 204
    case .tftInt8: return 205
    case .tftInt16: return 206
    case .tftInt32: return 207
    case .tftInt64: return 208
    case .tftHalf: return 209
    case .tftFloat: return 210
    case .tftDouble: return 211
    case .tftComplex64: return 212
    case .tftComplex128: return 213
    case .tftString: return 214
    case .tftBfloat16: return 215
    case .tftTensor: return 1000
    case .tftArray: return 1001
    case .tftOptional: return 1002
    case .tftLiteral: return 1003
    case .tftDataset: return 10102
    case .tftRagged: return 10103
    case .tftMutexLock: return 10202
    case .tftLegacyVariant: return 10203
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Tensorboard_FullTypeId] = [
    .tftUnset,
    .tftVar,
    .tftAny,
    .tftProduct,
    .tftNamed,
    .tftForEach,
    .tftCallable,
    .tftTensor,
    .tftArray,
    .tftOptional,
    .tftLiteral,
    .tftBool,
    .tftUint8,
    .tftUint16,
    .tftUint32,
    .tftUint64,
    .tftInt8,
    .tftInt16,
    .tftInt32,
    .tftInt64,
    .tftHalf,
    .tftFloat,
    .tftDouble,
    .tftBfloat16,
    .tftComplex64,
    .tftComplex128,
    .tftString,
    .tftDataset,
    .tftRagged,
    .tftMutexLock,
    .tftLegacyVariant,
  ]

}

/// Highly experimental and very likely to change.
/// This encoding uses tags instead of dedicated messages for regularity. In
/// particular the encoding imposes no restrictions on what the parameters of any
/// type should be, which in particular needs to be true for type symbols.
struct Tensorboard_FullTypeDef: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The principal type represented by this object. This may be a concrete type
  /// (Tensor, Dataset) a type variable (used for dependent types) a type
  /// symbol (Any, Union). See FullTypeId for details.
  var typeID: Tensorboard_FullTypeId = .tftUnset

  var args: [Tensorboard_FullTypeDef] = []

  /// Literal values of this type object, if the the type admits one.
  /// For example, a type variable admits a string attribute - its name.
  /// Shape-related types may admit int attributes - their static shape values.
  /// Fields for more data types to be added as needed.
  var attr: Tensorboard_FullTypeDef.OneOf_Attr? = nil

  var s: String {
    get {
      if case .s(let v)? = attr {return v}
      return String()
    }
    set {attr = .s(newValue)}
  }

  /// TODO(mdan): list/tensor, map? Need to reconcile with TFT_RECORD, etc.
  var i: Int64 {
    get {
      if case .i(let v)? = attr {return v}
      return 0
    }
    set {attr = .i(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Literal values of this type object, if the the type admits one.
  /// For example, a type variable admits a string attribute - its name.
  /// Shape-related types may admit int attributes - their static shape values.
  /// Fields for more data types to be added as needed.
  enum OneOf_Attr: Equatable, Sendable {
    case s(String)
    /// TODO(mdan): list/tensor, map? Need to reconcile with TFT_RECORD, etc.
    case i(Int64)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_FullTypeId: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TFT_UNSET"),
    1: .same(proto: "TFT_VAR"),
    2: .same(proto: "TFT_ANY"),
    3: .same(proto: "TFT_PRODUCT"),
    4: .same(proto: "TFT_NAMED"),
    20: .same(proto: "TFT_FOR_EACH"),
    100: .same(proto: "TFT_CALLABLE"),
    200: .same(proto: "TFT_BOOL"),
    201: .same(proto: "TFT_UINT8"),
    202: .same(proto: "TFT_UINT16"),
    203: .same(proto: "TFT_UINT32"),
    204: .same(proto: "TFT_UINT64"),
    205: .same(proto: "TFT_INT8"),
    206: .same(proto: "TFT_INT16"),
    207: .same(proto: "TFT_INT32"),
    208: .same(proto: "TFT_INT64"),
    209: .same(proto: "TFT_HALF"),
    210: .same(proto: "TFT_FLOAT"),
    211: .same(proto: "TFT_DOUBLE"),
    212: .same(proto: "TFT_COMPLEX64"),
    213: .same(proto: "TFT_COMPLEX128"),
    214: .same(proto: "TFT_STRING"),
    215: .same(proto: "TFT_BFLOAT16"),
    1000: .same(proto: "TFT_TENSOR"),
    1001: .same(proto: "TFT_ARRAY"),
    1002: .same(proto: "TFT_OPTIONAL"),
    1003: .same(proto: "TFT_LITERAL"),
    10102: .same(proto: "TFT_DATASET"),
    10103: .same(proto: "TFT_RAGGED"),
    10202: .same(proto: "TFT_MUTEX_LOCK"),
    10203: .same(proto: "TFT_LEGACY_VARIANT"),
  ]
}

extension Tensorboard_FullTypeDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FullTypeDef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_id"),
    2: .same(proto: "args"),
    3: .same(proto: "s"),
    4: .same(proto: "i"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.typeID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.attr != nil {try decoder.handleConflictingOneOf()}
          self.attr = .s(v)
        }
      }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.attr != nil {try decoder.handleConflictingOneOf()}
          self.attr = .i(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.typeID != .tftUnset {
      try visitor.visitSingularEnumField(value: self.typeID, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 2)
    }
    switch self.attr {
    case .s?: try {
      guard case .s(let v)? = self.attr else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .i?: try {
      guard case .i(let v)? = self.attr else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_FullTypeDef, rhs: Tensorboard_FullTypeDef) -> Bool {
    if lhs.typeID != rhs.typeID {return false}
    if lhs.args != rhs.args {return false}
    if lhs.attr != rhs.attr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
