// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorboard/compat/proto/struct.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _3: SwiftProtobuf.ProtobufAPIVersion_3 {}
  typealias Version = _3
}

/// `StructuredValue` represents a dynamically typed value representing various
/// data structures that are inspired by Python data structures typically used in
/// TensorFlow functions as inputs and outputs.
///
/// For example when saving a Layer there may be a `training` argument. If the
/// user passes a boolean True/False, that switches between two concrete
/// TensorFlow functions. In order to switch between them in the same way after
/// loading the SavedModel, we need to represent "True" and "False".
///
/// A more advanced example might be a function which takes a list of
/// dictionaries mapping from strings to Tensors. In order to map from
/// user-specified arguments `[{"a": tf.constant(1.)}, {"q": tf.constant(3.)}]`
/// after load to the right saved TensorFlow function, we need to represent the
/// nested structure and the strings, recording that we have a trace for anything
/// matching `[{"a": tf.TensorSpec(None, tf.float32)}, {"q": tf.TensorSpec([],
/// tf.float64)}]` as an example.
///
/// Likewise functions may return nested structures of Tensors, for example
/// returning a dictionary mapping from strings to Tensors. In order for the
/// loaded function to return the same structure we need to serialize it.
///
/// This is an ergonomic aid for working with loaded SavedModels, not a promise
/// to serialize all possible function signatures. For example we do not expect
/// to pickle generic Python objects, and ideally we'd stay language-agnostic.
struct Tensorboard_StructuredValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of value.
  var kind: OneOf_Kind? {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// Represents None.
  var noneValue: Tensorboard_NoneValue {
    get {
      if case .noneValue(let v)? = _storage._kind {return v}
      return Tensorboard_NoneValue()
    }
    set {_uniqueStorage()._kind = .noneValue(newValue)}
  }

  /// Represents a double-precision floating-point value (a Python `float`).
  var float64Value: Double {
    get {
      if case .float64Value(let v)? = _storage._kind {return v}
      return 0
    }
    set {_uniqueStorage()._kind = .float64Value(newValue)}
  }

  /// Represents a signed integer value, limited to 64 bits.
  /// Larger values from Python's arbitrary-precision integers are unsupported.
  var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = _storage._kind {return v}
      return 0
    }
    set {_uniqueStorage()._kind = .int64Value(newValue)}
  }

  /// Represents a string of Unicode characters stored in a Python `str`.
  /// In Python 3, this is exactly what type `str` is.
  /// In Python 2, this is the UTF-8 encoding of the characters.
  /// For strings with ASCII characters only (as often used in TensorFlow code)
  /// there is effectively no difference between the language versions.
  /// The obsolescent `unicode` type of Python 2 is not supported here.
  var stringValue: String {
    get {
      if case .stringValue(let v)? = _storage._kind {return v}
      return String()
    }
    set {_uniqueStorage()._kind = .stringValue(newValue)}
  }

  /// Represents a boolean value.
  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = _storage._kind {return v}
      return false
    }
    set {_uniqueStorage()._kind = .boolValue(newValue)}
  }

  /// Represents a TensorShape.
  var tensorShapeValue: Tensorboard_TensorShapeProto {
    get {
      if case .tensorShapeValue(let v)? = _storage._kind {return v}
      return Tensorboard_TensorShapeProto()
    }
    set {_uniqueStorage()._kind = .tensorShapeValue(newValue)}
  }

  /// Represents an enum value for dtype.
  var tensorDtypeValue: Tensorboard_DataType {
    get {
      if case .tensorDtypeValue(let v)? = _storage._kind {return v}
      return .dtInvalid
    }
    set {_uniqueStorage()._kind = .tensorDtypeValue(newValue)}
  }

  /// Represents a value for tf.TensorSpec.
  var tensorSpecValue: Tensorboard_TensorSpecProto {
    get {
      if case .tensorSpecValue(let v)? = _storage._kind {return v}
      return Tensorboard_TensorSpecProto()
    }
    set {_uniqueStorage()._kind = .tensorSpecValue(newValue)}
  }

  /// Represents a value for tf.TypeSpec.
  var typeSpecValue: Tensorboard_TypeSpecProto {
    get {
      if case .typeSpecValue(let v)? = _storage._kind {return v}
      return Tensorboard_TypeSpecProto()
    }
    set {_uniqueStorage()._kind = .typeSpecValue(newValue)}
  }

  /// Represents a value for tf.BoundedTensorSpec.
  var boundedTensorSpecValue: Tensorboard_BoundedTensorSpecProto {
    get {
      if case .boundedTensorSpecValue(let v)? = _storage._kind {return v}
      return Tensorboard_BoundedTensorSpecProto()
    }
    set {_uniqueStorage()._kind = .boundedTensorSpecValue(newValue)}
  }

  /// Represents a list of `Value`.
  var listValue: Tensorboard_ListValue {
    get {
      if case .listValue(let v)? = _storage._kind {return v}
      return Tensorboard_ListValue()
    }
    set {_uniqueStorage()._kind = .listValue(newValue)}
  }

  /// Represents a tuple of `Value`.
  var tupleValue: Tensorboard_TupleValue {
    get {
      if case .tupleValue(let v)? = _storage._kind {return v}
      return Tensorboard_TupleValue()
    }
    set {_uniqueStorage()._kind = .tupleValue(newValue)}
  }

  /// Represents a dict `Value`.
  var dictValue: Tensorboard_DictValue {
    get {
      if case .dictValue(let v)? = _storage._kind {return v}
      return Tensorboard_DictValue()
    }
    set {_uniqueStorage()._kind = .dictValue(newValue)}
  }

  /// Represents Python's namedtuple.
  var namedTupleValue: Tensorboard_NamedTupleValue {
    get {
      if case .namedTupleValue(let v)? = _storage._kind {return v}
      return Tensorboard_NamedTupleValue()
    }
    set {_uniqueStorage()._kind = .namedTupleValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of value.
  enum OneOf_Kind: Equatable {
    /// Represents None.
    case noneValue(Tensorboard_NoneValue)
    /// Represents a double-precision floating-point value (a Python `float`).
    case float64Value(Double)
    /// Represents a signed integer value, limited to 64 bits.
    /// Larger values from Python's arbitrary-precision integers are unsupported.
    case int64Value(Int64)
    /// Represents a string of Unicode characters stored in a Python `str`.
    /// In Python 3, this is exactly what type `str` is.
    /// In Python 2, this is the UTF-8 encoding of the characters.
    /// For strings with ASCII characters only (as often used in TensorFlow code)
    /// there is effectively no difference between the language versions.
    /// The obsolescent `unicode` type of Python 2 is not supported here.
    case stringValue(String)
    /// Represents a boolean value.
    case boolValue(Bool)
    /// Represents a TensorShape.
    case tensorShapeValue(Tensorboard_TensorShapeProto)
    /// Represents an enum value for dtype.
    case tensorDtypeValue(Tensorboard_DataType)
    /// Represents a value for tf.TensorSpec.
    case tensorSpecValue(Tensorboard_TensorSpecProto)
    /// Represents a value for tf.TypeSpec.
    case typeSpecValue(Tensorboard_TypeSpecProto)
    /// Represents a value for tf.BoundedTensorSpec.
    case boundedTensorSpecValue(Tensorboard_BoundedTensorSpecProto)
    /// Represents a list of `Value`.
    case listValue(Tensorboard_ListValue)
    /// Represents a tuple of `Value`.
    case tupleValue(Tensorboard_TupleValue)
    /// Represents a dict `Value`.
    case dictValue(Tensorboard_DictValue)
    /// Represents Python's namedtuple.
    case namedTupleValue(Tensorboard_NamedTupleValue)

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents None.
struct Tensorboard_NoneValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a Python list.
struct Tensorboard_ListValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [Tensorboard_StructuredValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a Python tuple.
struct Tensorboard_TupleValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [Tensorboard_StructuredValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a Python dict keyed by `str`.
/// The comment on Unicode from Value.string_value applies analogously.
struct Tensorboard_DictValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fields: Dictionary<String,Tensorboard_StructuredValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a (key, value) pair.
struct Tensorboard_PairValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: Tensorboard_StructuredValue {
    get {return _value ?? Tensorboard_StructuredValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Tensorboard_StructuredValue? = nil
}

/// Represents Python's namedtuple.
struct Tensorboard_NamedTupleValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var values: [Tensorboard_PairValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A protobuf to represent tf.TensorSpec.
struct Tensorboard_TensorSpecProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var shape: Tensorboard_TensorShapeProto {
    get {return _shape ?? Tensorboard_TensorShapeProto()}
    set {_shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  var hasShape: Bool {return self._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  mutating func clearShape() {self._shape = nil}

  var dtype: Tensorboard_DataType = .dtInvalid

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shape: Tensorboard_TensorShapeProto? = nil
}

/// A protobuf to represent tf.BoundedTensorSpec.
struct Tensorboard_BoundedTensorSpecProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var shape: Tensorboard_TensorShapeProto {
    get {return _shape ?? Tensorboard_TensorShapeProto()}
    set {_shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  var hasShape: Bool {return self._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  mutating func clearShape() {self._shape = nil}

  var dtype: Tensorboard_DataType = .dtInvalid

  var minimum: Tensorboard_TensorProto {
    get {return _minimum ?? Tensorboard_TensorProto()}
    set {_minimum = newValue}
  }
  /// Returns true if `minimum` has been explicitly set.
  var hasMinimum: Bool {return self._minimum != nil}
  /// Clears the value of `minimum`. Subsequent reads from it will return its default value.
  mutating func clearMinimum() {self._minimum = nil}

  var maximum: Tensorboard_TensorProto {
    get {return _maximum ?? Tensorboard_TensorProto()}
    set {_maximum = newValue}
  }
  /// Returns true if `maximum` has been explicitly set.
  var hasMaximum: Bool {return self._maximum != nil}
  /// Clears the value of `maximum`. Subsequent reads from it will return its default value.
  mutating func clearMaximum() {self._maximum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shape: Tensorboard_TensorShapeProto? = nil
  fileprivate var _minimum: Tensorboard_TensorProto? = nil
  fileprivate var _maximum: Tensorboard_TensorProto? = nil
}

/// Represents a tf.TypeSpec
struct Tensorboard_TypeSpecProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var typeSpecClass: Tensorboard_TypeSpecProto.TypeSpecClass {
    get {return _storage._typeSpecClass}
    set {_uniqueStorage()._typeSpecClass = newValue}
  }

  /// The value returned by TypeSpec._serialize().
  var typeState: Tensorboard_StructuredValue {
    get {return _storage._typeState ?? Tensorboard_StructuredValue()}
    set {_uniqueStorage()._typeState = newValue}
  }
  /// Returns true if `typeState` has been explicitly set.
  var hasTypeState: Bool {return _storage._typeState != nil}
  /// Clears the value of `typeState`. Subsequent reads from it will return its default value.
  mutating func clearTypeState() {_uniqueStorage()._typeState = nil}

  /// The name of the TypeSpec class.
  ///  * If type_spec_class == REGISTERED_TYPE_SPEC, the TypeSpec class is
  ///    the one registered under this name. For types registered outside
  ///    core TensorFlow by an add-on library, that library must be loaded
  ///    before this value can be deserialized by nested_structure_coder.
  ///  * If type_spec_class specifies a particular TypeSpec class, this field is
  ///    redundant with the type_spec_class enum, and is only used for error
  ///    reporting in older binaries that do not know the tupe_spec_class enum.
  var typeSpecClassName: String {
    get {return _storage._typeSpecClassName}
    set {_uniqueStorage()._typeSpecClassName = newValue}
  }

  /// The number of flat tensor components required by this TypeSpec.
  var numFlatComponents: Int32 {
    get {return _storage._numFlatComponents}
    set {_uniqueStorage()._numFlatComponents = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeSpecClass: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0

    /// tf.SparseTensorSpec
    case sparseTensorSpec // = 1

    /// tf.IndexedSlicesSpec
    case indexedSlicesSpec // = 2

    /// tf.RaggedTensorSpec
    case raggedTensorSpec // = 3

    /// tf.TensorArraySpec
    case tensorArraySpec // = 4

    /// tf.data.DatasetSpec
    case dataDatasetSpec // = 5

    /// IteratorSpec from data/ops/iterator_ops.py
    case dataIteratorSpec // = 6

    /// tf.OptionalSpec
    case optionalSpec // = 7

    /// PerReplicaSpec from distribute/values.py
    case perReplicaSpec // = 8

    /// tf.VariableSpec
    case variableSpec // = 9

    /// RowPartitionSpec from ragged/row_partition.py
    case rowPartitionSpec // = 10

    /// The type registered as type_spec_class_name.
    case registeredTypeSpec // = 12

    /// Subclasses of tf.ExtensionType
    case extensionTypeSpec // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .sparseTensorSpec
      case 2: self = .indexedSlicesSpec
      case 3: self = .raggedTensorSpec
      case 4: self = .tensorArraySpec
      case 5: self = .dataDatasetSpec
      case 6: self = .dataIteratorSpec
      case 7: self = .optionalSpec
      case 8: self = .perReplicaSpec
      case 9: self = .variableSpec
      case 10: self = .rowPartitionSpec
      case 12: self = .registeredTypeSpec
      case 13: self = .extensionTypeSpec
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .sparseTensorSpec: return 1
      case .indexedSlicesSpec: return 2
      case .raggedTensorSpec: return 3
      case .tensorArraySpec: return 4
      case .dataDatasetSpec: return 5
      case .dataIteratorSpec: return 6
      case .optionalSpec: return 7
      case .perReplicaSpec: return 8
      case .variableSpec: return 9
      case .rowPartitionSpec: return 10
      case .registeredTypeSpec: return 12
      case .extensionTypeSpec: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static var allCases: [Tensorboard_TypeSpecProto.TypeSpecClass] = [
      .unknown,
      .sparseTensorSpec,
      .indexedSlicesSpec,
      .raggedTensorSpec,
      .tensorArraySpec,
      .dataDatasetSpec,
      .dataIteratorSpec,
      .optionalSpec,
      .perReplicaSpec,
      .variableSpec,
      .rowPartitionSpec,
      .registeredTypeSpec,
      .extensionTypeSpec,
    ]

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tensorboard_StructuredValue: @unchecked Sendable {}
extension Tensorboard_StructuredValue.OneOf_Kind: @unchecked Sendable {}
extension Tensorboard_NoneValue: @unchecked Sendable {}
extension Tensorboard_ListValue: @unchecked Sendable {}
extension Tensorboard_TupleValue: @unchecked Sendable {}
extension Tensorboard_DictValue: @unchecked Sendable {}
extension Tensorboard_PairValue: @unchecked Sendable {}
extension Tensorboard_NamedTupleValue: @unchecked Sendable {}
extension Tensorboard_TensorSpecProto: @unchecked Sendable {}
extension Tensorboard_BoundedTensorSpecProto: @unchecked Sendable {}
extension Tensorboard_TypeSpecProto: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorboard"

extension Tensorboard_StructuredValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StructuredValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "none_value"),
    11: .standard(proto: "float64_value"),
    12: .standard(proto: "int64_value"),
    13: .standard(proto: "string_value"),
    14: .standard(proto: "bool_value"),
    31: .standard(proto: "tensor_shape_value"),
    32: .standard(proto: "tensor_dtype_value"),
    33: .standard(proto: "tensor_spec_value"),
    34: .standard(proto: "type_spec_value"),
    35: .standard(proto: "bounded_tensor_spec_value"),
    51: .standard(proto: "list_value"),
    52: .standard(proto: "tuple_value"),
    53: .standard(proto: "dict_value"),
    54: .standard(proto: "named_tuple_value"),
  ]

  fileprivate class _StorageClass {
    var _kind: Tensorboard_StructuredValue.OneOf_Kind?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Tensorboard_NoneValue?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .noneValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .noneValue(v)
          }
        }()
        case 11: try {
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {
            if _storage._kind != nil {try decoder.handleConflictingOneOf()}
            _storage._kind = .float64Value(v)
          }
        }()
        case 12: try {
          var v: Int64?
          try decoder.decodeSingularSInt64Field(value: &v)
          if let v = v {
            if _storage._kind != nil {try decoder.handleConflictingOneOf()}
            _storage._kind = .int64Value(v)
          }
        }()
        case 13: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._kind != nil {try decoder.handleConflictingOneOf()}
            _storage._kind = .stringValue(v)
          }
        }()
        case 14: try {
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {
            if _storage._kind != nil {try decoder.handleConflictingOneOf()}
            _storage._kind = .boolValue(v)
          }
        }()
        case 31: try {
          var v: Tensorboard_TensorShapeProto?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .tensorShapeValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .tensorShapeValue(v)
          }
        }()
        case 32: try {
          var v: Tensorboard_DataType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._kind != nil {try decoder.handleConflictingOneOf()}
            _storage._kind = .tensorDtypeValue(v)
          }
        }()
        case 33: try {
          var v: Tensorboard_TensorSpecProto?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .tensorSpecValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .tensorSpecValue(v)
          }
        }()
        case 34: try {
          var v: Tensorboard_TypeSpecProto?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .typeSpecValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .typeSpecValue(v)
          }
        }()
        case 35: try {
          var v: Tensorboard_BoundedTensorSpecProto?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .boundedTensorSpecValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .boundedTensorSpecValue(v)
          }
        }()
        case 51: try {
          var v: Tensorboard_ListValue?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .listValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .listValue(v)
          }
        }()
        case 52: try {
          var v: Tensorboard_TupleValue?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .tupleValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .tupleValue(v)
          }
        }()
        case 53: try {
          var v: Tensorboard_DictValue?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .dictValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .dictValue(v)
          }
        }()
        case 54: try {
          var v: Tensorboard_NamedTupleValue?
          var hadOneofValue = false
          if let current = _storage._kind {
            hadOneofValue = true
            if case .namedTupleValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._kind = .namedTupleValue(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._kind {
      case .noneValue?: try {
        guard case .noneValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .float64Value?: try {
        guard case .float64Value(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 11)
      }()
      case .int64Value?: try {
        guard case .int64Value(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularSInt64Field(value: v, fieldNumber: 12)
      }()
      case .stringValue?: try {
        guard case .stringValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      }()
      case .boolValue?: try {
        guard case .boolValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      }()
      case .tensorShapeValue?: try {
        guard case .tensorShapeValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .tensorDtypeValue?: try {
        guard case .tensorDtypeValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 32)
      }()
      case .tensorSpecValue?: try {
        guard case .tensorSpecValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .typeSpecValue?: try {
        guard case .typeSpecValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .boundedTensorSpecValue?: try {
        guard case .boundedTensorSpecValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .listValue?: try {
        guard case .listValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .tupleValue?: try {
        guard case .tupleValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .dictValue?: try {
        guard case .dictValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .namedTupleValue?: try {
        guard case .namedTupleValue(let v)? = _storage._kind else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_StructuredValue, rhs: Tensorboard_StructuredValue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._kind != rhs_storage._kind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_NoneValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NoneValue"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_NoneValue, rhs: Tensorboard_NoneValue) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_ListValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_ListValue, rhs: Tensorboard_ListValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TupleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TupleValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_TupleValue, rhs: Tensorboard_TupleValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_DictValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DictValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_StructuredValue>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorboard_StructuredValue>.self, value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_DictValue, rhs: Tensorboard_DictValue) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_PairValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_PairValue, rhs: Tensorboard_PairValue) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_NamedTupleValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NamedTupleValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_NamedTupleValue, rhs: Tensorboard_NamedTupleValue) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TensorSpecProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TensorSpecProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "shape"),
    3: .same(proto: "dtype"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.dtype) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.dtype != .dtInvalid {
      try visitor.visitSingularEnumField(value: self.dtype, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_TensorSpecProto, rhs: Tensorboard_TensorSpecProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.dtype != rhs.dtype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_BoundedTensorSpecProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoundedTensorSpecProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "shape"),
    3: .same(proto: "dtype"),
    4: .same(proto: "minimum"),
    5: .same(proto: "maximum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shape) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.dtype) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minimum) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maximum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._shape {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.dtype != .dtInvalid {
      try visitor.visitSingularEnumField(value: self.dtype, fieldNumber: 3)
    }
    try { if let v = self._minimum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maximum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_BoundedTensorSpecProto, rhs: Tensorboard_BoundedTensorSpecProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._shape != rhs._shape {return false}
    if lhs.dtype != rhs.dtype {return false}
    if lhs._minimum != rhs._minimum {return false}
    if lhs._maximum != rhs._maximum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TypeSpecProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypeSpecProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "type_spec_class"),
    2: .standard(proto: "type_state"),
    3: .standard(proto: "type_spec_class_name"),
    4: .standard(proto: "num_flat_components"),
  ]

  fileprivate class _StorageClass {
    var _typeSpecClass: Tensorboard_TypeSpecProto.TypeSpecClass = .unknown
    var _typeState: Tensorboard_StructuredValue? = nil
    var _typeSpecClassName: String = String()
    var _numFlatComponents: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _typeSpecClass = source._typeSpecClass
      _typeState = source._typeState
      _typeSpecClassName = source._typeSpecClassName
      _numFlatComponents = source._numFlatComponents
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._typeSpecClass) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._typeState) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._typeSpecClassName) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._numFlatComponents) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._typeSpecClass != .unknown {
        try visitor.visitSingularEnumField(value: _storage._typeSpecClass, fieldNumber: 1)
      }
      try { if let v = _storage._typeState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._typeSpecClassName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._typeSpecClassName, fieldNumber: 3)
      }
      if _storage._numFlatComponents != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numFlatComponents, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tensorboard_TypeSpecProto, rhs: Tensorboard_TypeSpecProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._typeSpecClass != rhs_storage._typeSpecClass {return false}
        if _storage._typeState != rhs_storage._typeState {return false}
        if _storage._typeSpecClassName != rhs_storage._typeSpecClassName {return false}
        if _storage._numFlatComponents != rhs_storage._numFlatComponents {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorboard_TypeSpecProto.TypeSpecClass: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SPARSE_TENSOR_SPEC"),
    2: .same(proto: "INDEXED_SLICES_SPEC"),
    3: .same(proto: "RAGGED_TENSOR_SPEC"),
    4: .same(proto: "TENSOR_ARRAY_SPEC"),
    5: .same(proto: "DATA_DATASET_SPEC"),
    6: .same(proto: "DATA_ITERATOR_SPEC"),
    7: .same(proto: "OPTIONAL_SPEC"),
    8: .same(proto: "PER_REPLICA_SPEC"),
    9: .same(proto: "VARIABLE_SPEC"),
    10: .same(proto: "ROW_PARTITION_SPEC"),
    12: .same(proto: "REGISTERED_TYPE_SPEC"),
    13: .same(proto: "EXTENSION_TYPE_SPEC"),
  ]
}
